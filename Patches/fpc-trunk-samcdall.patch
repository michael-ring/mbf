Index: compiler/arm/cpuinfo.pas
===================================================================
--- compiler/arm/cpuinfo.pas	(revision 42324)
+++ compiler/arm/cpuinfo.pas	(working copy)
@@ -482,6 +482,92 @@
       ct_mk64fx512vmd12,
 
       { Atmel }
+      ct_samd10c13a,
+      ct_samd10c14a,
+      ct_samd10d13a,
+      ct_samd10d14a,
+      ct_samd11c13a,
+      ct_samd11c14a,
+      ct_samd11d14am,
+      ct_samd11d14as,
+      ct_samd20e14,
+      ct_samd20e15,
+      ct_samd20e16,
+      ct_samd20e17,
+      ct_samd20e18,
+      ct_samd20g14,
+      ct_samd20g15,
+      ct_samd20g16,
+      ct_samd20g17,
+      ct_samd20g18,
+      ct_samd20j14,
+      ct_samd20j15,
+      ct_samd20j16,
+      ct_samd20j17,
+      ct_samd20j18,
+      ct_samc20e15a,
+      ct_samc20e16a,
+      ct_samc20e17a,
+      ct_samc20e18a,
+      ct_samc20g15a,
+      ct_samc20g16a,
+      ct_samc20g17a,
+      ct_samc20g18a,
+      ct_samc20j15a,
+      ct_samc20j16a,
+      ct_samc20j17a,
+      ct_samc20j17au,
+      ct_samc20j18a,
+      ct_samc20j18au,
+      ct_samc20n17a,
+      ct_samc20n18a,
+      ct_samc21e15a,
+      ct_samc21e16a,
+      ct_samc21e17a,
+      ct_samc21e18a,
+      ct_samc21g15a,
+      ct_samc21g16a,
+      ct_samc21g17a,
+      ct_samc21g18a,
+      ct_samc21j15a,
+      ct_samc21j16a,
+      ct_samc21j17a,
+      ct_samc21j17au,
+      ct_samc21j18a,
+      ct_samc21j18au,
+      ct_samc21n17a,
+      ct_samc21n18a,
+      ct_samd21e15a,
+      ct_samd21e15b,
+      ct_samd21e15bu,
+      ct_samd21e15l,
+      ct_samd21e16a,
+      ct_samd21e16b,
+      ct_samd21e16bu,
+      ct_samd21e16l,
+      ct_samd21e17a,
+      ct_samd21e18a,
+      ct_samd21g15a,
+      ct_samd21g15b,
+      ct_samd21g15l,
+      ct_samd21g16a,
+      ct_samd21g16b,
+      ct_samd21g16l,
+      ct_samd21g17a,
+      ct_samd21g17au,
+      ct_samd21g18a,
+      ct_samd21g18au,
+      ct_samd21j15a,
+      ct_samd21j15b,
+      ct_samd21j16a,
+      ct_samd21j16b,
+      ct_samd21j17a,
+      ct_samd21j18a,
+      ct_samc21xpro,
+      ct_samd10xmini,
+      ct_samd20xpro,
+      ct_arduinozero,
+      ct_samd21xpro,
       ct_sam3x8e,
       ct_arduino_due,
       ct_flip_n_click,
@@ -996,6 +1082,93 @@
       (controllertypestr:'MK64FX512VMD12';controllerunitstr:'MK64F12'; cputype:cpu_armv7em; fputype:fpu_soft; flashbase:$00000000;      flashsize:$00080000;   srambase:$20000000; sramsize:$00020000),
 
       { Atmel }
+(controllertypestr:'SAMD10C13A'        ;controllerunitstr:'SAMD10C13A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00002000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD10C14A'        ;controllerunitstr:'SAMD10C14A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD10D13A'        ;controllerunitstr:'SAMD10D13A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00002000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD10D14A'        ;controllerunitstr:'SAMD10D14A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD11C13A'        ;controllerunitstr:'SAMD11C13A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00002000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD11C14A'        ;controllerunitstr:'SAMD11C14A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD11D14AM'       ;controllerunitstr:'SAMD11D14AM'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD11D14AS'       ;controllerunitstr:'SAMD11D14AS'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD20E14'         ;controllerunitstr:'SAMD20E14'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00000800),
+(controllertypestr:'SAMD20E15'         ;controllerunitstr:'SAMD20E15'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD20E16'         ;controllerunitstr:'SAMD20E16'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD20E17'         ;controllerunitstr:'SAMD20E17'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD20E18'         ;controllerunitstr:'SAMD20E18'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD20G14'         ;controllerunitstr:'SAMD20G14'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00000800),
+(controllertypestr:'SAMD20G15'         ;controllerunitstr:'SAMD20G15'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD20G16'         ;controllerunitstr:'SAMD20G16'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD20G17'         ;controllerunitstr:'SAMD20G17'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD20G18'         ;controllerunitstr:'SAMD20G18'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD20J14'         ;controllerunitstr:'SAMD20J14'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00000800),
+(controllertypestr:'SAMD20J15'         ;controllerunitstr:'SAMD20J15'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD20J16'         ;controllerunitstr:'SAMD20J16'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD20J17'         ;controllerunitstr:'SAMD20J17'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD20J18'         ;controllerunitstr:'SAMD20J18'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMC20E15A'        ;controllerunitstr:'SAMC20E15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC20E16A'        ;controllerunitstr:'SAMC20E16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC20E17A'        ;controllerunitstr:'SAMC20E17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC20E18A'        ;controllerunitstr:'SAMC20E18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC20G15A'        ;controllerunitstr:'SAMC20G15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC20G16A'        ;controllerunitstr:'SAMC20G16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC20G17A'        ;controllerunitstr:'SAMC20G17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC20G18A'        ;controllerunitstr:'SAMC20G18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC20J15A'        ;controllerunitstr:'SAMC20J15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC20J16A'        ;controllerunitstr:'SAMC20J16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC20J17A'        ;controllerunitstr:'SAMC20J17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC20J17AU'       ;controllerunitstr:'SAMC20J17AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC20J18A'        ;controllerunitstr:'SAMC20J18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC20J18AU'       ;controllerunitstr:'SAMC20J18AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC20N17A'        ;controllerunitstr:'SAMC20N17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC20N18A'        ;controllerunitstr:'SAMC20N18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC21E15A'        ;controllerunitstr:'SAMC21E15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC21E16A'        ;controllerunitstr:'SAMC21E16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC21E17A'        ;controllerunitstr:'SAMC21E17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC21E18A'        ;controllerunitstr:'SAMC21E18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC21G15A'        ;controllerunitstr:'SAMC21G15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC21G16A'        ;controllerunitstr:'SAMC21G16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC21G17A'        ;controllerunitstr:'SAMC21G17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC21G18A'        ;controllerunitstr:'SAMC21G18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC21J15A'        ;controllerunitstr:'SAMC21J15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$08000; srambase:$20000000; sramsize:$01000),
+(controllertypestr:'SAMC21J16A'        ;controllerunitstr:'SAMC21J16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$10000; srambase:$20000000; sramsize:$02000),
+(controllertypestr:'SAMC21J17A'        ;controllerunitstr:'SAMC21J17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC21J17AU'       ;controllerunitstr:'SAMC21J17AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC21J18A'        ;controllerunitstr:'SAMC21J18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC21J18AU'       ;controllerunitstr:'SAMC21J18AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMC21N17A'        ;controllerunitstr:'SAMC21N17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$20000; srambase:$20000000; sramsize:$04000),
+(controllertypestr:'SAMC21N18A'        ;controllerunitstr:'SAMC21N18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$40000; srambase:$20000000; sramsize:$08000),
+(controllertypestr:'SAMD21E15A'        ;controllerunitstr:'SAMD21E15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21E15B'        ;controllerunitstr:'SAMD21E15B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21E15BU'       ;controllerunitstr:'SAMD21E15BU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21E15L'        ;controllerunitstr:'SAMD21E15L'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21E16A'        ;controllerunitstr:'SAMD21E16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21E16B'        ;controllerunitstr:'SAMD21E16B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21E16BU'       ;controllerunitstr:'SAMD21E16BU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21E16L'        ;controllerunitstr:'SAMD21E16L'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21E17A'        ;controllerunitstr:'SAMD21E17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD21E18A'        ;controllerunitstr:'SAMD21E18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD21G15A'        ;controllerunitstr:'SAMD21G15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21G15B'        ;controllerunitstr:'SAMD21G15B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21G15L'        ;controllerunitstr:'SAMD21G15L'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21G16A'        ;controllerunitstr:'SAMD21G16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21G16B'        ;controllerunitstr:'SAMD21G16B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21G16L'        ;controllerunitstr:'SAMD21G16L'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21G17A'        ;controllerunitstr:'SAMD21G17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD21G17AU'       ;controllerunitstr:'SAMD21G17AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD21G18A'        ;controllerunitstr:'SAMD21G18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD21G18AU'       ;controllerunitstr:'SAMD21G18AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD21J15A'        ;controllerunitstr:'SAMD21J15A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21J15B'        ;controllerunitstr:'SAMD21J15B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00008000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD21J16A'        ;controllerunitstr:'SAMD21J16A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21J16B'        ;controllerunitstr:'SAMD21J16B'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00010000; srambase:$20000000; sramsize:$00002000),
+(controllertypestr:'SAMD21J17A'        ;controllerunitstr:'SAMD21J17A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00020000; srambase:$20000000; sramsize:$00004000),
+(controllertypestr:'SAMD21J18A'        ;controllerunitstr:'SAMD21J18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+
+(controllertypestr:'SAMC21XPRO'          ;controllerunitstr:'SAMC21J18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD10XMINI'         ;controllerunitstr:'SAMD10D14A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00004000; srambase:$20000000; sramsize:$00001000),
+(controllertypestr:'SAMD20XPRO'         ;controllerunitstr:'SAMD20J18'    ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'ARDUINOZERO'         ;controllerunitstr:'SAMD21G18AU'  ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
+(controllertypestr:'SAMD21XPRO'          ;controllerunitstr:'SAMD21J18A'   ; cputype:cpu_armv6m; fputype:fpu_soft; flashbase:$00000000; flashsize:$00040000; srambase:$20000000; sramsize:$00008000),
       (controllertypestr:'ATSAM3X8E';     controllerunitstr:'SAM3X8E'; cputype:cpu_armv7m; fputype:fpu_soft; flashbase:$00080000; flashsize:$00040000; srambase:$20000000; sramsize:$00010000),
       (controllertypestr:'ARDUINO_DUE';   controllerunitstr:'SAM3X8E'; cputype:cpu_armv7m; fputype:fpu_soft; flashbase:$00080000; flashsize:$00040000; srambase:$20000000; sramsize:$00010000),
       (controllertypestr:'FLIP_N_CLICK';  controllerunitstr:'SAM3X8E'; cputype:cpu_armv7m; fputype:fpu_soft; flashbase:$00080000; flashsize:$00040000; srambase:$20000000; sramsize:$00010000),
Index: compiler/systems/t_embed.pas
===================================================================
--- compiler/systems/t_embed.pas	(revision 42324)
+++ compiler/systems/t_embed.pas	(working copy)
@@ -603,6 +603,92 @@
       ct_freedom_k22f,
  
       { Atmel }
+      ct_samd10c13a,
+      ct_samd10c14a,
+      ct_samd10d13a,
+      ct_samd10d14a,
+      ct_samd11c13a,
+      ct_samd11c14a,
+      ct_samd11d14am,
+      ct_samd11d14as,
+      ct_samd20e14,
+      ct_samd20e15,
+      ct_samd20e16,
+      ct_samd20e17,
+      ct_samd20e18,
+      ct_samd20g14,
+      ct_samd20g15,
+      ct_samd20g16,
+      ct_samd20g17,
+      ct_samd20g18,
+      ct_samd20j14,
+      ct_samd20j15,
+      ct_samd20j16,
+      ct_samd20j17,
+      ct_samd20j18,
+      ct_samc20e15a,
+      ct_samc20e16a,
+      ct_samc20e17a,
+      ct_samc20e18a,
+      ct_samc20g15a,
+      ct_samc20g16a,
+      ct_samc20g17a,
+      ct_samc20g18a,
+      ct_samc20j15a,
+      ct_samc20j16a,
+      ct_samc20j17a,
+      ct_samc20j17au,
+      ct_samc20j18a,
+      ct_samc20j18au,
+      ct_samc20n17a,
+      ct_samc20n18a,
+      ct_samc21e15a,
+      ct_samc21e16a,
+      ct_samc21e17a,
+      ct_samc21e18a,
+      ct_samc21g15a,
+      ct_samc21g16a,
+      ct_samc21g17a,
+      ct_samc21g18a,
+      ct_samc21j15a,
+      ct_samc21j16a,
+      ct_samc21j17a,
+      ct_samc21j17au,
+      ct_samc21j18a,
+      ct_samc21j18au,
+      ct_samc21n17a,
+      ct_samc21n18a,
+      ct_samd21e15a,
+      ct_samd21e15b,
+      ct_samd21e15bu,
+      ct_samd21e15l,
+      ct_samd21e16a,
+      ct_samd21e16b,
+      ct_samd21e16bu,
+      ct_samd21e16l,
+      ct_samd21e17a,
+      ct_samd21e18a,
+      ct_samd21g15a,
+      ct_samd21g15b,
+      ct_samd21g15l,
+      ct_samd21g16a,
+      ct_samd21g16b,
+      ct_samd21g16l,
+      ct_samd21g17a,
+      ct_samd21g17au,
+      ct_samd21g18a,
+      ct_samd21g18au,
+      ct_samd21j15a,
+      ct_samd21j15b,
+      ct_samd21j16a,
+      ct_samd21j16b,
+      ct_samd21j17a,
+      ct_samd21j18a,
+      ct_samc21xpro,
+      ct_samd10xmini,
+      ct_samd20xpro,
+      ct_arduinozero,
+      ct_samd21xpro,
       ct_sam3x8e,
       ct_arduino_due,
       ct_flip_n_click,
Index: rtl/embedded/Makefile
===================================================================
--- rtl/embedded/Makefile	(revision 42324)
+++ rtl/embedded/Makefile	(working copy)
@@ -373,6 +373,11 @@
 endif
 ifeq ($(SUBARCH),armv6m)
 CPU_UNITS=lpc8xx lpc11xx lpc122x stm32f0xx nrf51 cortexm0
+CPU_UNITS+=samc21e15a samc21e16a samc21e17a samc21e18a samc21g15a samc21g16a samc21g17a samc21g18a samc21j15a samc21j16a samc21j17a samc21j17au samc21j18a samc21j18au samd10c13a samd10c14a
+CPU_UNITS+=samd10d13a samd10d14a samd11c13a samd11c14a samd11d14am samd11d14as samd20e14
+CPU_UNITS+=samd20e15 samd20e16 samd20e17 samd20e18 samd20g14 samd20g15 samd20g16 samd20g17 samd20g18 samd20j14 samd20j15 samd20j16 samd20j17 samd20j18 samd21e15a
+CPU_UNITS+=samd21e15b samd21e15bu samd21e15l samd21e16a samd21e16b samd21e16bu samd21e16l samd21e17a samd21e18a samd21g15a samd21g15b samd21g15l samd21g16a samd21g16b samd21g16l
+CPU_UNITS+=samd21g17a samd21g17au samd21g18a samd21g18au samd21j15a samd21j15b samd21j16a samd21j16b samd21j17a samd21j18a
 CPU_UNITS_DEFINED=1
 endif
 ifeq ($(SUBARCH),armv7a)
Index: rtl/embedded/Makefile.fpc
===================================================================
--- rtl/embedded/Makefile.fpc	(revision 42324)
+++ rtl/embedded/Makefile.fpc	(working copy)
@@ -88,6 +88,11 @@
 endif
 ifeq ($(SUBARCH),armv6m)
 CPU_UNITS=lpc8xx lpc11xx lpc122x stm32f0xx nrf51 cortexm0
+CPU_UNITS+=samc21e15a samc21e16a samc21e17a samc21e18a samc21g15a samc21g16a samc21g17a samc21g18a samc21j15a samc21j16a samc21j17a samc21j17au samc21j18a samc21j18au samd10c13a samd10c14a
+CPU_UNITS+=samd10d13a samd10d14a samd11c13a samd11c14a samd11d14am samd11d14as samd20e14
+CPU_UNITS+=samd20e15 samd20e16 samd20e17 samd20e18 samd20g14 samd20g15 samd20g16 samd20g17 samd20g18 samd20j14 samd20j15 samd20j16 samd20j17 samd20j18 samd21e15a
+CPU_UNITS+=samd21e15b samd21e15bu samd21e15l samd21e16a samd21e16b samd21e16bu samd21e16l samd21e17a samd21e18a samd21g15a samd21g15b samd21g15l samd21g16a samd21g16b samd21g16l 
+CPU_UNITS+=samd21g17a samd21g17au samd21g18a samd21g18au samd21j15a samd21j15b samd21j16a samd21j16b samd21j17a samd21j18a
 CPU_UNITS_DEFINED=1
 endif
 ifeq ($(SUBARCH),armv7a)
Index: rtl/embedded/arm/samc21e15a.pp
===================================================================
--- rtl/embedded/arm/samc21e15a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21e15a.pp	(working copy)
@@ -0,0 +1,1125 @@
+unit samc21e15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21E15A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21E15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21E15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21E15A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21E15A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21E15A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21E15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21E15A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21E15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21E15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21E15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21E15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21E15A Serial Communication Interface 3 (SERCOM3) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21E15A Control Area Network 0 (CAN0) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21E15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21E15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21E15A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21E15A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21E15A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21E15A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21E15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21E15A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21E15A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21E15A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21E15A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21E15A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21E15A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21E15A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long CAN0_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak CAN0_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21e16a.pp
===================================================================
--- rtl/embedded/arm/samc21e16a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21e16a.pp	(working copy)
@@ -0,0 +1,1125 @@
+unit samc21e16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21E16A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21E16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21E16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21E16A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21E16A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21E16A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21E16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21E16A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21E16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21E16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21E16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21E16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21E16A Serial Communication Interface 3 (SERCOM3) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21E16A Control Area Network 0 (CAN0) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21E16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21E16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21E16A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21E16A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21E16A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21E16A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21E16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21E16A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21E16A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21E16A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21E16A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21E16A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21E16A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21E16A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long CAN0_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak CAN0_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21e17a.pp
===================================================================
--- rtl/embedded/arm/samc21e17a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21e17a.pp	(working copy)
@@ -0,0 +1,1125 @@
+unit samc21e17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21E17A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21E17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21E17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21E17A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21E17A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21E17A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21E17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21E17A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21E17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21E17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21E17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21E17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21E17A Serial Communication Interface 3 (SERCOM3) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21E17A Control Area Network 0 (CAN0) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21E17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21E17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21E17A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21E17A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21E17A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21E17A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21E17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21E17A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21E17A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21E17A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21E17A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21E17A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21E17A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21E17A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long CAN0_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak CAN0_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21e18a.pp
===================================================================
--- rtl/embedded/arm/samc21e18a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21e18a.pp	(working copy)
@@ -0,0 +1,1125 @@
+unit samc21e18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21E18A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21E18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21E18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21E18A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21E18A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21E18A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21E18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21E18A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21E18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21E18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21E18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21E18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21E18A Serial Communication Interface 3 (SERCOM3) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21E18A Control Area Network 0 (CAN0) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21E18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21E18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21E18A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21E18A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21E18A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21E18A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21E18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21E18A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21E18A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21E18A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21E18A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21E18A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21E18A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21E18A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long CAN0_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak CAN0_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21g15a.pp
===================================================================
--- rtl/embedded/arm/samc21g15a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21g15a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21g15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21G15A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21G15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21G15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21G15A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21G15A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21G15A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21G15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21G15A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21G15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21G15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21G15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21G15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21G15A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21G15A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21G15A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21G15A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21G15A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21G15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21G15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21G15A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21G15A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21G15A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21G15A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21G15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21G15A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21G15A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21G15A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21G15A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21G15A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21G15A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21G15A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21g16a.pp
===================================================================
--- rtl/embedded/arm/samc21g16a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21g16a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21g16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21G16A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21G16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21G16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21G16A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21G16A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21G16A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21G16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21G16A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21G16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21G16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21G16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21G16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21G16A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21G16A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21G16A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21G16A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21G16A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21G16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21G16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21G16A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21G16A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21G16A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21G16A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21G16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21G16A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21G16A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21G16A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21G16A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21G16A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21G16A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21G16A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21g17a.pp
===================================================================
--- rtl/embedded/arm/samc21g17a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21g17a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21g17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21G17A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21G17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21G17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21G17A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21G17A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21G17A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21G17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21G17A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21G17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21G17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21G17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21G17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21G17A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21G17A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21G17A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21G17A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21G17A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21G17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21G17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21G17A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21G17A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21G17A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21G17A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21G17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21G17A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21G17A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21G17A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21G17A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21G17A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21G17A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21G17A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21g18a.pp
===================================================================
--- rtl/embedded/arm/samc21g18a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21g18a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21g18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21G18A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21G18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21G18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21G18A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21G18A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21G18A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21G18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21G18A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21G18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21G18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21G18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21G18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21G18A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21G18A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21G18A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21G18A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21G18A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21G18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21G18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21G18A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21G18A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21G18A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21G18A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21G18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21G18A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21G18A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21G18A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21G18A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21G18A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21G18A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21G18A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j15a.pp
===================================================================
--- rtl/embedded/arm/samc21j15a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j15a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J15A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J15A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J15A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J15A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J15A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J15A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J15A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J15A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J15A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J15A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J15A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J15A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J15A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J15A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J15A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J15A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J15A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J15A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J15A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J15A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J15A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j16a.pp
===================================================================
--- rtl/embedded/arm/samc21j16a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j16a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J16A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J16A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J16A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J16A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J16A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J16A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J16A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J16A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J16A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J16A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J16A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J16A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J16A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J16A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J16A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J16A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J16A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J16A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J16A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J16A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J16A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j17a.pp
===================================================================
--- rtl/embedded/arm/samc21j17a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j17a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J17A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J17A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J17A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J17A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J17A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J17A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J17A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J17A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J17A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J17A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J17A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J17A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J17A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J17A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J17A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J17A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J17A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J17A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J17A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J17A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J17A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j17au.pp
===================================================================
--- rtl/embedded/arm/samc21j17au.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j17au.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j17au;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J17AU System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J17AU Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J17AU Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J17AU External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J17AU Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J17AU Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J17AU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J17AU Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J17AU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J17AU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J17AU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J17AU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J17AU Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J17AU Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J17AU Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J17AU Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J17AU Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J17AU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J17AU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J17AU Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J17AU Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J17AU Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J17AU Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J17AU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J17AU Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J17AU Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J17AU Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J17AU Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J17AU Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J17AU Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J17AU Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j18a.pp
===================================================================
--- rtl/embedded/arm/samc21j18a.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j18a.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J18A System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J18A External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J18A Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J18A Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J18A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J18A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J18A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J18A Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J18A Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J18A Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J18A Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J18A Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J18A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J18A Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J18A Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J18A Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J18A Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J18A Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J18A Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J18A Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J18A Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samc21j18au.pp
===================================================================
--- rtl/embedded/arm/samc21j18au.pp	(nonexistent)
+++ rtl/embedded/arm/samc21j18au.pp	(working copy)
@@ -0,0 +1,1143 @@
+unit samc21j18au;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    SYSTEM_IRQn = 0,                   //   0 SAMC21J18AU System Interrupts 
+    WDT_IRQn    = 1,                   //   1 SAMC21J18AU Watchdog Timer (WDT) 
+    RTC_IRQn    = 2,                   //   2 SAMC21J18AU Real-Time Counter (RTC) 
+    EIC_IRQn    = 3,                   //   3 SAMC21J18AU External Interrupt Controller (EIC) 
+    FREQM_IRQn  = 4,                   //   4 SAMC21J18AU Frequency Meter (FREQM) 
+    TSENS_IRQn  = 5,                   //   5 SAMC21J18AU Temperature Sensor (TSENS) 
+    NVMCTRL_IRQn = 6,                  //   6 SAMC21J18AU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 7,                   //   7 SAMC21J18AU Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMC21J18AU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMC21J18AU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMC21J18AU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMC21J18AU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMC21J18AU Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMC21J18AU Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMC21J18AU Serial Communication Interface 5 (SERCOM5) 
+    CAN0_IRQn   = 15,                  //  15 SAMC21J18AU Control Area Network 0 (CAN0) 
+    CAN1_IRQn   = 16,                  //  16 SAMC21J18AU Control Area Network 1 (CAN1) 
+    TCC0_IRQn   = 17,                  //  17 SAMC21J18AU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 18,                  //  18 SAMC21J18AU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 19,                  //  19 SAMC21J18AU Timer Counter Control 2 (TCC2) 
+    TC0_IRQn    = 20,                  //  20 SAMC21J18AU Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 21,                  //  21 SAMC21J18AU Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 22,                  //  22 SAMC21J18AU Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 23,                  //  23 SAMC21J18AU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 24,                  //  24 SAMC21J18AU Basic Timer Counter 4 (TC4) 
+    ADC0_IRQn   = 25,                  //  25 SAMC21J18AU Analog Digital Converter 0 (ADC0) 
+    ADC1_IRQn   = 26,                  //  26 SAMC21J18AU Analog Digital Converter 1 (ADC1) 
+    AC_IRQn     = 27,                  //  27 SAMC21J18AU Analog Comparators (AC) 
+    DAC_IRQn    = 28,                  //  28 SAMC21J18AU Digital Analog Converter (DAC) 
+    SDADC_IRQn  = 29,                  //  29 SAMC21J18AU Sigma-Delta Analog Digital Converter (SDADC) 
+    PTC_IRQn    = 30                   //  30 SAMC21J18AU Peripheral Touch Controller (PTC) 
+  );
+
+  TMPU_Type_Registers = record
+  end;
+
+  TARM_MPU_Region_t_Registers = record
+  end;
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    DBGCTRL     : byte;                // Debug Control 
+    WINCTRL     : byte;                // Window Control 
+    Reserved1   : array[0..0] of byte;
+    SCALER      : array[0..3] of byte; // Scaler n 
+    COMPCTRL    : array[0..3] of longword; // Comparator Control n 
+    SYNCBUSY    : longword;            // Synchronization Busy 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    REFCTRL     : byte;                // Reference Control 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : word;                // Input Control 
+    CTRLC       : word;                // Control C 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sample Time Control 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    Reserved1   : array[0..1] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..2] of byte;
+    SYNCBUSY    : word;                // Synchronization Busy 
+    Reserved4   : array[0..1] of byte;
+    RESULT      : word;                // Result 
+    Reserved5   : array[0..1] of byte;
+    SEQCTRL     : longword;            // Sequence Control 
+    CALIB       : word;                // Calibration 
+  end;
+
+  TCan_Registers = record
+    CREL        : longword;            // Core Release 
+    ENDN        : longword;            // Endian 
+    MRCFG       : longword;            // Message RAM Configuration 
+    DBTP        : longword;            // Fast Bit Timing and Prescaler 
+    TEST        : longword;            // Test 
+    RWD         : longword;            // RAM Watchdog 
+    CCCR        : longword;            // CC Control 
+    NBTP        : longword;            // Nominal Bit Timing and Prescaler 
+    TSCC        : longword;            // Timestamp Counter Configuration 
+    TSCV        : longword;            // Timestamp Counter Value 
+    TOCC        : longword;            // Timeout Counter Configuration 
+    TOCV        : longword;            // Timeout Counter Value 
+    Reserved1   : array[0..15] of byte;
+    ECR         : longword;            // Error Counter 
+    PSR         : longword;            // Protocol Status 
+    TDCR        : longword;            // Extended ID Filter Configuration 
+    Reserved2   : array[0..3] of byte;
+    IR          : longword;            // Interrupt 
+    IE          : longword;            // Interrupt Enable 
+    ILS         : longword;            // Interrupt Line Select 
+    ILE         : longword;            // Interrupt Line Enable 
+    Reserved3   : array[0..31] of byte;
+    GFC         : longword;            // Global Filter Configuration 
+    SIDFC       : longword;            // Standard ID Filter Configuration 
+    XIDFC       : longword;            // Extended ID Filter Configuration 
+    Reserved4   : array[0..3] of byte;
+    XIDAM       : longword;            // Extended ID AND Mask 
+    HPMS        : longword;            // High Priority Message Status 
+    NDAT1       : longword;            // New Data 1 
+    NDAT2       : longword;            // New Data 2 
+    RXF0C       : longword;            // Rx FIFO 0 Configuration 
+    RXF0S       : longword;            // Rx FIFO 0 Status 
+    RXF0A       : longword;            // Rx FIFO 0 Acknowledge 
+    RXBC        : longword;            // Rx Buffer Configuration 
+    RXF1C       : longword;            // Rx FIFO 1 Configuration 
+    RXF1S       : longword;            // Rx FIFO 1 Status 
+    RXF1A       : longword;            // Rx FIFO 1 Acknowledge 
+    RXESC       : longword;            // Rx Buffer / FIFO Element Size Configuration 
+    TXBC        : longword;            // Tx Buffer Configuration 
+    TXFQS       : longword;            // Tx FIFO / Queue Status 
+    TXESC       : longword;            // Tx Buffer Element Size Configuration 
+    TXBRP       : longword;            // Tx Buffer Request Pending 
+    TXBAR       : longword;            // Tx Buffer Add Request 
+    TXBCR       : longword;            // Tx Buffer Cancellation Request 
+    TXBTO       : longword;            // Tx Buffer Transmission Occurred 
+    TXBCF       : longword;            // Tx Buffer Cancellation Finished 
+    TXBTIE      : longword;            // Tx Buffer Transmission Interrupt Enable 
+    TXBCIE      : longword;            // Tx Buffer Cancellation Finished Interrupt Enable 
+    Reserved5   : array[0..7] of byte;
+    TXEFC       : longword;            // Tx Event FIFO Configuration 
+    TXEFS       : longword;            // Tx Event FIFO Status 
+    TXEFA       : longword;            // Tx Event FIFO Acknowledge 
+  end;
+
+  TCanMramRxbe_Registers = record
+    RXBE_0      : longword;            // Rx Buffer Element 0 
+    RXBE_1      : longword;            // Rx Buffer Element 1 
+    RXBE_DATA   : array[0..15] of longword; // Rx Buffer Element Data 
+  end;
+
+  TCanMramRxf0e_Registers = record
+    RXF0E_0     : longword;            // Rx FIFO 0 Element 0 
+    RXF0E_1     : longword;            // Rx FIFO 0 Element 1 
+    RXF0E_DATA  : array[0..15] of longword; // Rx FIFO 0 Element Data 
+  end;
+
+  TCanMramRxf1e_Registers = record
+    RXF1E_0     : longword;            // Rx FIFO 1 Element 0 
+    RXF1E_1     : longword;            // Rx FIFO 1 Element 1 
+    RXF1E_DATA  : array[0..15] of longword; // Rx FIFO 1 Element Data 
+  end;
+
+  TCanMramSidfe_Registers = record
+    SIDFE_0     : longword;            // Standard Message ID Filter Element 
+  end;
+
+  TCanMramTxbe_Registers = record
+    TXBE_0      : longword;            // Tx Buffer Element 0 
+    TXBE_1      : longword;            // Tx Buffer Element 1 
+    TXBE_DATA   : array[0..15] of longword; // Tx Buffer Element Data 
+  end;
+
+  TCanMramTxefe_Registers = record
+    TXEFE_0     : longword;            // Tx Event FIFO Element 0 
+    TXEFE_1     : longword;            // Tx Event FIFO Element 1 
+  end;
+
+  TCanMramXifde_Registers = record
+    XIDFE_0     : longword;            // Extended Message ID Filter Element 0 
+    XIDFE_1     : longword;            // Extended Message ID Filter Element 1 
+  end;
+
+  TCcl_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SEQCTRL     : array[0..1] of byte; // SEQ Control x 
+    Reserved2   : array[0..1] of byte;
+    LUTCTRL     : array[0..3] of longword; // LUT Control x 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+    Reserved3   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDivas_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    STATUS      : byte;                // Status 
+    Reserved2   : array[0..2] of byte;
+    DIVIDEND    : longword;            // Dividend 
+    DIVISOR     : longword;            // Divisor 
+    RESULT      : longword;            // Result 
+    REM         : longword;            // Remainder 
+    SQRNUM      : longword;            // Square Root Input 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved1   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved2   : array[0..3847] of byte;
+    ENTRY0      : longword;            // CoreSight ROM Table Entry 0 
+    ENTRY1      : longword;            // CoreSight ROM Table Entry 1 
+    &END        : longword;            // CoreSight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // CoreSight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRLA       : byte;                // Control 
+    NMICTRL     : byte;                // NMI Control 
+    NMIFLAG     : word;                // NMI Interrupt Flag 
+    SYNCBUSY    : longword;            // Syncbusy register 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    ASYNCH      : longword;            // EIC Asynchronous edge Detection Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..10] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    SWEVT       : longword;            // Software Event 
+    CHANNEL     : array[0..11] of longword; // Channel n 
+    Reserved2   : array[0..47] of byte;
+    USER        : array[0..46] of longword; // User Multiplexer n 
+  end;
+
+  TFreqm_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CFGA        : word;                // Config A register 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Count Value Register 
+  end;
+
+  TGclk_Registers = record
+    CTRLA       : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    Reserved2   : array[0..23] of byte;
+    GENCTRL     : array[0..8] of longword; // Generic Clock Generator Control 
+    Reserved3   : array[0..59] of byte;
+    PCHCTRL     : array[0..40] of longword; // Peripheral Clock Control 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    MCFG        : array[0..15] of longword; // Master Configuration 
+    SCFG        : array[0..15] of longword; // Slave Configuration 
+    Prs         : array[0..3] of THmatrixbPrs_Registers; // HmatrixbPrs groups [CLK_AHB_ID] 
+    Reserved1   : array[0..95] of byte;
+    MRCR        : longword;            // Master Remap Control 
+    Reserved2   : array[0..11] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMclk_Registers = record
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    CPUDIV      : byte;                // CPU Clock Division 
+    Reserved2   : array[0..10] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+    Reserved6   : array[0..5] of byte;
+    PBLDATA0    : longword;            // Page Buffer Load Data 0 
+    PBLDATA1    : longword;            // Page Buffer Load Data 1 
+  end;
+
+  TOscctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    XOSCCTRL    : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    CFDPRESC    : byte;                // Clock Failure Detector Prescaler 
+    EVCTRL      : byte;                // Event Control 
+    OSC48MCTRL  : byte;                // 48MHz Internal Oscillator (OSC48M) Control 
+    OSC48MDIV   : byte;                // OSC48M Divider 
+    OSC48MSTUP  : byte;                // OSC48M Startup Time 
+    Reserved1   : array[0..0] of byte;
+    OSC48MSYNCBUSY : longword;         // OSC48M Synchronization Busy 
+    DPLLCTRLA   : byte;                // DPLL Control 
+    Reserved2   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // Digital Core Configuration 
+    DPLLPRESC   : byte;                // DPLL Prescaler 
+    Reserved3   : array[0..2] of byte;
+    DPLLSYNCBUSY : byte;               // DPLL Synchronization Busy 
+    Reserved4   : array[0..2] of byte;
+    DPLLSTATUS  : byte;                // DPLL Status 
+    Reserved5   : array[0..6] of byte;
+    CAL48M      : longword;            // 48MHz Oscillator Calibration 
+  end;
+
+  TOsc32kctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    RTCCTRL     : longword;            // Clock selection 
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    CFDCTRL     : byte;                // Clock Failure Detector Control 
+    EVCTRL      : byte;                // Event Control 
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : longword;            // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+  end;
+
+  TPac_Registers = record
+    WRCTRL      : longword;            // Write control 
+    EVCTRL      : byte;                // Event control 
+    Reserved1   : array[0..2] of byte;
+    INTENCLR    : byte;                // Interrupt enable clear 
+    INTENSET    : byte;                // Interrupt enable set 
+    Reserved2   : array[0..5] of byte;
+    INTFLAGAHB  : longword;            // Bridge interrupt flag status 
+    INTFLAGA    : longword;            // Peripheral interrupt flag status - Bridge A 
+    INTFLAGB    : longword;            // Peripheral interrupt flag status - Bridge B 
+    INTFLAGC    : longword;            // Peripheral interrupt flag status - Bridge C 
+    Reserved3   : array[0..19] of byte;
+    STATUSA     : longword;            // Peripheral write protection status - Bridge A 
+    STATUSB     : longword;            // Peripheral write protection status - Bridge B 
+    STATUSC     : longword;            // Peripheral write protection status - Bridge C 
+  end;
+
+  TPm_Registers = record
+    Reserved1   : array[0..0] of byte;
+    SLEEPCFG    : byte;                // Sleep Configuration 
+    Reserved2   : array[0..5] of byte;
+    STDBYCFG    : word;                // Standby Configuration 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    EVCTRL      : longword;            // Event Input Control 
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved1   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRstc_Registers = record
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRLA       : word;                // MODE0 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE0 Event Control 
+    INTENCLR    : word;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE0 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE0 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved4   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRLA       : word;                // MODE1 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE1 Event Control 
+    INTENCLR    : word;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE1 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE1 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved4   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved5   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRLA       : word;                // MODE2 Control A 
+    Reserved1   : array[0..1] of byte;
+    EVCTRL      : longword;            // MODE2 Event Control 
+    INTENCLR    : word;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : word;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : word;                // MODE2 Interrupt Flag Status and Clear 
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // MODE2 Synchronization Busy Status 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved3   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved4   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSdadc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    CTRLB       : word;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    SEQSTATUS   : byte;                // Sequence Status 
+    INPUTCTRL   : byte;                // Input Control 
+    CTRLC       : byte;                // Control C 
+    WINCTRL     : byte;                // Window Monitor Control 
+    WINLT       : longword;            // Window Monitor Lower Threshold 
+    WINUT       : longword;            // Window Monitor Upper Threshold 
+    OFFSETCORR  : longword;            // Offset Correction 
+    GAINCORR    : word;                // Gain Correction 
+    SHIFTCORR   : byte;                // Shift Correction 
+    Reserved1   : array[0..0] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved2   : array[0..2] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    RESULT      : longword;            // Result 
+    SEQCTRL     : byte;                // Sequence Control 
+    Reserved3   : array[0..2] of byte;
+    ANACTRL     : byte;                // Analog Control 
+    Reserved4   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    CTRLC       : longword;            // USART Control C 
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved1   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved5   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved6   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSupc_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Power and Clocks Status 
+    BODVDD      : longword;            // BODVDD Control 
+    BODCORE     : longword;            // BODCORE Control 
+    VREG        : longword;            // VREG Control 
+    VREF        : longword;            // VREF Control 
+  end;
+
+  TTalCtis_Registers = record
+    CTICTRLA    : byte;                // Cross-Trigger Interface n Control A 
+    CTIMASK     : byte;                // Cross-Trigger Interface n Mask 
+  end;
+
+  TTal_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    RSTCTRL     : byte;                // Reset Control 
+    EXTCTRL     : byte;                // External Break Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    GLOBMASK    : byte;                // Global Break Requests Mask 
+    HALT        : byte;                // Debug Halt Request 
+    RESTART     : byte;                // Debug Restart Request 
+    BRKSTATUS   : word;                // Break Request Status 
+    Ctis        : array[0..2] of TTalCtis_Registers; // TalCtis groups [CTI_NUM] 
+    Reserved3   : array[0..9] of byte;
+    INTSTATUS   : array[0..30] of byte; // Interrupt n Status 
+    Reserved4   : array[0..32] of byte;
+    IRQTRIG     : word;                // Interrupt Trigger 
+    Reserved5   : array[0..1] of byte;
+    CPUIRQS     : array[0..0] of longword; // Interrupt Status for CPU n 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : byte;                // COUNT8 Count 
+    Reserved2   : array[0..5] of byte;
+    PER         : byte;                // COUNT8 Period 
+    CC          : array[0..1] of byte; // COUNT8 Compare and Capture 
+    Reserved3   : array[0..16] of byte;
+    PERBUF      : byte;                // COUNT8 Period Buffer 
+    CCBUF       : array[0..1] of byte; // COUNT8 Compare and Capture Buffer 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : word;                // COUNT16 Count 
+    Reserved2   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare and Capture 
+    Reserved3   : array[0..15] of byte;
+    CCBUF       : array[0..1] of word; // COUNT16 Compare and Capture Buffer 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    WAVE        : byte;                // Waveform Generation Control 
+    DRVCTRL     : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    SYNCBUSY    : longword;            // Synchronization Status 
+    COUNT       : longword;            // COUNT32 Count 
+    Reserved2   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare and Capture 
+    Reserved3   : array[0..11] of byte;
+    CCBUF       : array[0..1] of longword; // COUNT32 Compare and Capture Buffer 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTBUF     : word;                // Pattern Buffer 
+    Reserved6   : array[0..5] of byte;
+    PERBUF      : longword;            // Period Buffer 
+    CCBUF       : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TTsens_Registers = record
+    CTRLA       : byte;                // Control A Register 
+    CTRLB       : byte;                // Control B Register 
+    CTRLC       : byte;                // Control C Register 
+    EVCTRL      : byte;                // Event Control Register 
+    INTENCLR    : byte;                // Interrupt Enable Clear Register 
+    INTENSET    : byte;                // Interrupt Enable Set Register 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear Register 
+    STATUS      : byte;                // Status Register 
+    SYNCBUSY    : longword;            // Synchronization Busy Register 
+    VALUE       : longword;            // Value Register 
+    WINLT       : longword;            // Window Monitor Lower Threshold Register 
+    WINUT       : longword;            // Window Monitor Upper Threshold Register 
+    GAIN        : longword;            // Gain Register 
+    OFFSET      : longword;            // Offset Register 
+    CAL         : longword;            // Calibration Register 
+    DBGCTRL     : byte;                // Debug Control Register 
+  end;
+
+  TWdt_Registers = record
+    CTRLA       : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42005000;
+  ADC0_BASE     = $42004400;
+  ADC1_BASE     = $42004800;
+  CAN0_BASE     = $42001C00;
+  CAN1_BASE     = $42002000;
+  CCL_BASE      = $42005C00;
+  DAC_BASE      = $42005400;
+  DIVAS_BASE    = $48000000;
+  DIVAS_IOBUS_BASE= $60000200;
+  DMAC_BASE     = $41006000;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40002800;
+  EVSYS_BASE    = $42000000;
+  FREQM_BASE    = $40002C00;
+  GCLK_BASE     = $40001C00;
+  HMATRIXHS_BASE= $4100A000;
+  MCLK_BASE     = $40000800;
+  MTB_BASE      = $41008000;
+  NVMCTRL_BASE  = $41004000;
+  OSCCTRL_BASE  = $40001000;
+  OSC32KCTRL_BASE= $40001400;
+  PAC_BASE      = $40000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41000000;
+  PORT_IOBUS_BASE= $60000000;
+  RSTC_BASE     = $40000C00;
+  RTC_BASE      = $40002400;
+  SDADC_BASE    = $42004C00;
+  SERCOM0_BASE  = $42000400;
+  SERCOM1_BASE  = $42000800;
+  SERCOM2_BASE  = $42000C00;
+  SERCOM3_BASE  = $42001000;
+  SERCOM4_BASE  = $42001400;
+  SERCOM5_BASE  = $42001800;
+  SUPC_BASE     = $40001800;
+  TAL_BASE      = $42006000;
+  TC0_BASE      = $42003000;
+  TC1_BASE      = $42003400;
+  TC2_BASE      = $42003800;
+  TC3_BASE      = $42003C00;
+  TC4_BASE      = $42004000;
+  TCC0_BASE     = $42002400;
+  TCC1_BASE     = $42002800;
+  TCC2_BASE     = $42002C00;
+  TSENS_BASE    = $40003000;
+  WDT_BASE      = $40002000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC0          : TAdc_Registers absolute ADC0_BASE;
+  ADC1          : TAdc_Registers absolute ADC1_BASE;
+  CAN0          : TCan_Registers absolute CAN0_BASE;
+  CAN1          : TCan_Registers absolute CAN1_BASE;
+  CCL           : TCcl_Registers absolute CCL_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DIVAS         : TDivas_Registers absolute DIVAS_BASE;
+  DIVAS_IOBUS   : TDivas_Registers absolute DIVAS_IOBUS_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  FREQM         : TFreqm_Registers absolute FREQM_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  HMATRIXHS     : THmatrixb_Registers absolute HMATRIXHS_BASE;
+  MCLK          : TMclk_Registers absolute MCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  OSCCTRL       : TOscctrl_Registers absolute OSCCTRL_BASE;
+  OSC32KCTRL    : TOsc32kctrl_Registers absolute OSC32KCTRL_BASE;
+  PAC           : TPac_Registers absolute PAC_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RSTC          : TRstc_Registers absolute RSTC_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SDADC         : TSdadc_Registers absolute SDADC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SUPC          : TSupc_Registers absolute SUPC_BASE;
+  TAL           : TTal_Registers absolute TAL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  TSENS         : TTsens_Registers absolute TSENS_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure SYSTEM_interrupt; external name 'SYSTEM_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure FREQM_interrupt; external name 'FREQM_interrupt';
+procedure TSENS_interrupt; external name 'TSENS_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure CAN0_interrupt; external name 'CAN0_interrupt';
+procedure CAN1_interrupt; external name 'CAN1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure ADC0_interrupt; external name 'ADC0_interrupt';
+procedure ADC1_interrupt; external name 'ADC1_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure SDADC_interrupt; external name 'SDADC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long SYSTEM_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long FREQM_interrupt
+  .long TSENS_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long CAN0_interrupt
+  .long CAN1_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long ADC0_interrupt
+  .long ADC1_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long SDADC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak SYSTEM_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak FREQM_interrupt
+  .weak TSENS_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak CAN0_interrupt
+  .weak CAN1_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak ADC0_interrupt
+  .weak ADC1_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak SDADC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set SYSTEM_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set FREQM_interrupt, Haltproc
+  .set TSENS_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set CAN0_interrupt, Haltproc
+  .set CAN1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set ADC0_interrupt, Haltproc
+  .set ADC1_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set SDADC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd10c13a.pp
===================================================================
--- rtl/embedded/arm/samd10c13a.pp	(nonexistent)
+++ rtl/embedded/arm/samd10c13a.pp	(working copy)
@@ -0,0 +1,772 @@
+unit samd10c13a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD10C13A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD10C13A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD10C13A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD10C13A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD10C13A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD10C13A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD10C13A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD10C13A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD10C13A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD10C13A Serial Communication Interface 1 (SERCOM1) 
+    TCC0_IRQn   = 12,                  //  12 SAMD10C13A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD10C13A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD10C13A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD10C13A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD10C13A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD10C13A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD10C13A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd10c14a.pp
===================================================================
--- rtl/embedded/arm/samd10c14a.pp	(nonexistent)
+++ rtl/embedded/arm/samd10c14a.pp	(working copy)
@@ -0,0 +1,772 @@
+unit samd10c14a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD10C14A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD10C14A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD10C14A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD10C14A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD10C14A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD10C14A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD10C14A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD10C14A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD10C14A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD10C14A Serial Communication Interface 1 (SERCOM1) 
+    TCC0_IRQn   = 12,                  //  12 SAMD10C14A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD10C14A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD10C14A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD10C14A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD10C14A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD10C14A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD10C14A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd10d13a.pp
===================================================================
--- rtl/embedded/arm/samd10d13a.pp	(nonexistent)
+++ rtl/embedded/arm/samd10d13a.pp	(working copy)
@@ -0,0 +1,764 @@
+unit samd10d13a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD10D13A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD10D13A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD10D13A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD10D13A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD10D13A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD10D13A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD10D13A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD10D13A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD10D13A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD10D13A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD10D13A Serial Communication Interface 2 (SERCOM2) 
+    TCC0_IRQn   = 12,                  //  12 SAMD10D13A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD10D13A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD10D13A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD10D13A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD10D13A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD10D13A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD10D13A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd10d14a.pp
===================================================================
--- rtl/embedded/arm/samd10d14a.pp	(nonexistent)
+++ rtl/embedded/arm/samd10d14a.pp	(working copy)
@@ -0,0 +1,764 @@
+unit samd10d14a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD10D14A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD10D14A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD10D14A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD10D14A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD10D14A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD10D14A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD10D14A Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD10D14A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD10D14A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD10D14A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD10D14A Serial Communication Interface 2 (SERCOM2) 
+    TCC0_IRQn   = 12,                  //  12 SAMD10D14A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD10D14A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD10D14A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD10D14A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD10D14A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD10D14A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD10D14A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd11c13a.pp
===================================================================
--- rtl/embedded/arm/samd11c13a.pp	(nonexistent)
+++ rtl/embedded/arm/samd11c13a.pp	(working copy)
@@ -0,0 +1,821 @@
+unit samd11c13a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD11C13A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD11C13A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD11C13A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD11C13A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD11C13A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD11C13A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD11C13A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD11C13A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD11C13A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD11C13A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD11C13A Serial Communication Interface 1 (SERCOM1) 
+    TCC0_IRQn   = 12,                  //  12 SAMD11C13A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD11C13A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD11C13A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD11C13A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD11C13A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD11C13A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD11C13A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd11c14a.pp
===================================================================
--- rtl/embedded/arm/samd11c14a.pp	(nonexistent)
+++ rtl/embedded/arm/samd11c14a.pp	(working copy)
@@ -0,0 +1,835 @@
+unit samd11c14a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD11C14A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD11C14A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD11C14A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD11C14A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD11C14A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD11C14A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD11C14A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD11C14A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD11C14A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD11C14A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD11C14A Serial Communication Interface 1 (SERCOM1) 
+    TCC0_IRQn   = 12,                  //  12 SAMD11C14A Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD11C14A Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD11C14A Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD11C14A Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD11C14A Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD11C14A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD11C14A Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long 0
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd11d14am.pp
===================================================================
--- rtl/embedded/arm/samd11d14am.pp	(nonexistent)
+++ rtl/embedded/arm/samd11d14am.pp	(working copy)
@@ -0,0 +1,841 @@
+unit samd11d14am;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD11D14AM Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD11D14AM System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD11D14AM Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD11D14AM Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD11D14AM External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD11D14AM Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD11D14AM Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD11D14AM Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD11D14AM Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD11D14AM Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD11D14AM Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD11D14AM Serial Communication Interface 2 (SERCOM2) 
+    TCC0_IRQn   = 12,                  //  12 SAMD11D14AM Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD11D14AM Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD11D14AM Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD11D14AM Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD11D14AM Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD11D14AM Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD11D14AM Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd11d14as.pp
===================================================================
--- rtl/embedded/arm/samd11d14as.pp	(nonexistent)
+++ rtl/embedded/arm/samd11d14as.pp	(working copy)
@@ -0,0 +1,841 @@
+unit samd11d14as;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD11D14AS Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD11D14AS System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD11D14AS Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD11D14AS Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD11D14AS External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD11D14AS Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD11D14AS Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD11D14AS Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD11D14AS Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD11D14AS Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD11D14AS Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD11D14AS Serial Communication Interface 2 (SERCOM2) 
+    TCC0_IRQn   = 12,                  //  12 SAMD11D14AS Timer Counter Control (TCC0) 
+    TC1_IRQn    = 13,                  //  13 SAMD11D14AS Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 14,                  //  14 SAMD11D14AS Basic Timer Counter 2 (TC2) 
+    ADC_IRQn    = 15,                  //  15 SAMD11D14AS Analog Digital Converter (ADC) 
+    AC_IRQn     = 16,                  //  16 SAMD11D14AS Analog Comparators (AC) 
+    DAC_IRQn    = 17,                  //  17 SAMD11D14AS Digital Analog Converter (DAC) 
+    PTC_IRQn    = 18                   //  18 SAMD11D14AS Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..0] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..0] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..7] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved7   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+  end;
+
+const
+  AC_BASE       = $42002400;
+  ADC_BASE      = $42002000;
+  DAC_BASE      = $42002800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SYSCTRL_BASE  = $40000800;
+  TC1_BASE      = $42001800;
+  TC2_BASE      = $42001C00;
+  TCC0_BASE     = $42001400;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long TCC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak TCC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20e14.pp
===================================================================
--- rtl/embedded/arm/samd20e14.pp	(nonexistent)
+++ rtl/embedded/arm/samd20e14.pp	(working copy)
@@ -0,0 +1,661 @@
+unit samd20e14;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20E14 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20E14 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20E14 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20E14 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20E14 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20E14 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20E14 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20E14 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20E14 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20E14 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20E14 Serial Communication Interface 3 (SERCOM3) 
+    TC0_IRQn    = 13,                  //  13 SAMD20E14 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20E14 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20E14 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20E14 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20E14 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20E14 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20E14 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20E14 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20E14 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20E14 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20e15.pp
===================================================================
--- rtl/embedded/arm/samd20e15.pp	(nonexistent)
+++ rtl/embedded/arm/samd20e15.pp	(working copy)
@@ -0,0 +1,661 @@
+unit samd20e15;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20E15 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20E15 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20E15 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20E15 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20E15 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20E15 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20E15 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20E15 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20E15 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20E15 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20E15 Serial Communication Interface 3 (SERCOM3) 
+    TC0_IRQn    = 13,                  //  13 SAMD20E15 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20E15 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20E15 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20E15 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20E15 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20E15 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20E15 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20E15 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20E15 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20E15 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20e16.pp
===================================================================
--- rtl/embedded/arm/samd20e16.pp	(nonexistent)
+++ rtl/embedded/arm/samd20e16.pp	(working copy)
@@ -0,0 +1,661 @@
+unit samd20e16;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20E16 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20E16 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20E16 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20E16 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20E16 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20E16 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20E16 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20E16 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20E16 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20E16 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20E16 Serial Communication Interface 3 (SERCOM3) 
+    TC0_IRQn    = 13,                  //  13 SAMD20E16 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20E16 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20E16 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20E16 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20E16 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20E16 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20E16 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20E16 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20E16 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20E16 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20e17.pp
===================================================================
--- rtl/embedded/arm/samd20e17.pp	(nonexistent)
+++ rtl/embedded/arm/samd20e17.pp	(working copy)
@@ -0,0 +1,661 @@
+unit samd20e17;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20E17 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20E17 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20E17 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20E17 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20E17 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20E17 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20E17 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20E17 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20E17 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20E17 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20E17 Serial Communication Interface 3 (SERCOM3) 
+    TC0_IRQn    = 13,                  //  13 SAMD20E17 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20E17 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20E17 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20E17 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20E17 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20E17 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20E17 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20E17 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20E17 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20E17 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20e18.pp
===================================================================
--- rtl/embedded/arm/samd20e18.pp	(nonexistent)
+++ rtl/embedded/arm/samd20e18.pp	(working copy)
@@ -0,0 +1,661 @@
+unit samd20e18;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20E18 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20E18 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20E18 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20E18 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20E18 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20E18 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20E18 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20E18 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20E18 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20E18 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20E18 Serial Communication Interface 3 (SERCOM3) 
+    TC0_IRQn    = 13,                  //  13 SAMD20E18 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20E18 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20E18 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20E18 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20E18 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20E18 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20E18 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20E18 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20E18 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20E18 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20g14.pp
===================================================================
--- rtl/embedded/arm/samd20g14.pp	(nonexistent)
+++ rtl/embedded/arm/samd20g14.pp	(working copy)
@@ -0,0 +1,673 @@
+unit samd20g14;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20G14 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20G14 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20G14 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20G14 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20G14 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20G14 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20G14 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20G14 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20G14 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20G14 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20G14 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20G14 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20G14 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20G14 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20G14 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20G14 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20G14 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20G14 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20G14 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20G14 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20G14 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20G14 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20G14 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20g15.pp
===================================================================
--- rtl/embedded/arm/samd20g15.pp	(nonexistent)
+++ rtl/embedded/arm/samd20g15.pp	(working copy)
@@ -0,0 +1,673 @@
+unit samd20g15;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20G15 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20G15 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20G15 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20G15 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20G15 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20G15 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20G15 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20G15 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20G15 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20G15 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20G15 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20G15 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20G15 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20G15 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20G15 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20G15 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20G15 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20G15 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20G15 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20G15 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20G15 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20G15 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20G15 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20g16.pp
===================================================================
--- rtl/embedded/arm/samd20g16.pp	(nonexistent)
+++ rtl/embedded/arm/samd20g16.pp	(working copy)
@@ -0,0 +1,673 @@
+unit samd20g16;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20G16 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20G16 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20G16 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20G16 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20G16 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20G16 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20G16 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20G16 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20G16 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20G16 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20G16 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20G16 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20G16 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20G16 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20G16 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20G16 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20G16 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20G16 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20G16 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20G16 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20G16 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20G16 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20G16 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20g17.pp
===================================================================
--- rtl/embedded/arm/samd20g17.pp	(nonexistent)
+++ rtl/embedded/arm/samd20g17.pp	(working copy)
@@ -0,0 +1,673 @@
+unit samd20g17;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20G17 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20G17 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20G17 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20G17 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20G17 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20G17 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20G17 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20G17 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20G17 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20G17 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20G17 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20G17 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20G17 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20G17 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20G17 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20G17 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20G17 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20G17 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20G17 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20G17 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20G17 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20G17 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20G17 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20g18.pp
===================================================================
--- rtl/embedded/arm/samd20g18.pp	(nonexistent)
+++ rtl/embedded/arm/samd20g18.pp	(working copy)
@@ -0,0 +1,673 @@
+unit samd20g18;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20G18 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20G18 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20G18 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20G18 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20G18 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20G18 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20G18 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20G18 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20G18 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20G18 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20G18 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20G18 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20G18 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20G18 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20G18 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20G18 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20G18 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20G18 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20G18 Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 21,                  //  21 SAMD20G18 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20G18 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20G18 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20G18 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20j14.pp
===================================================================
--- rtl/embedded/arm/samd20j14.pp	(nonexistent)
+++ rtl/embedded/arm/samd20j14.pp	(working copy)
@@ -0,0 +1,685 @@
+unit samd20j14;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20J14 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20J14 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20J14 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20J14 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20J14 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20J14 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20J14 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20J14 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20J14 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20J14 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20J14 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20J14 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20J14 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20J14 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20J14 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20J14 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20J14 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20J14 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20J14 Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 19,                  //  19 SAMD20J14 Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 20,                  //  20 SAMD20J14 Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 21,                  //  21 SAMD20J14 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20J14 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20J14 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20J14 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20j15.pp
===================================================================
--- rtl/embedded/arm/samd20j15.pp	(nonexistent)
+++ rtl/embedded/arm/samd20j15.pp	(working copy)
@@ -0,0 +1,685 @@
+unit samd20j15;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20J15 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20J15 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20J15 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20J15 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20J15 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20J15 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20J15 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20J15 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20J15 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20J15 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20J15 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20J15 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20J15 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20J15 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20J15 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20J15 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20J15 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20J15 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20J15 Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 19,                  //  19 SAMD20J15 Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 20,                  //  20 SAMD20J15 Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 21,                  //  21 SAMD20J15 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20J15 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20J15 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20J15 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20j16.pp
===================================================================
--- rtl/embedded/arm/samd20j16.pp	(nonexistent)
+++ rtl/embedded/arm/samd20j16.pp	(working copy)
@@ -0,0 +1,685 @@
+unit samd20j16;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20J16 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20J16 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20J16 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20J16 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20J16 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20J16 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20J16 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20J16 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20J16 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20J16 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20J16 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20J16 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20J16 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20J16 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20J16 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20J16 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20J16 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20J16 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20J16 Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 19,                  //  19 SAMD20J16 Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 20,                  //  20 SAMD20J16 Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 21,                  //  21 SAMD20J16 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20J16 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20J16 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20J16 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20j17.pp
===================================================================
--- rtl/embedded/arm/samd20j17.pp	(nonexistent)
+++ rtl/embedded/arm/samd20j17.pp	(working copy)
@@ -0,0 +1,685 @@
+unit samd20j17;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20J17 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20J17 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20J17 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20J17 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20J17 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20J17 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20J17 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20J17 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20J17 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20J17 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20J17 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20J17 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20J17 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20J17 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20J17 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20J17 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20J17 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20J17 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20J17 Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 19,                  //  19 SAMD20J17 Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 20,                  //  20 SAMD20J17 Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 21,                  //  21 SAMD20J17 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20J17 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20J17 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20J17 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd20j18.pp
===================================================================
--- rtl/embedded/arm/samd20j18.pp	(nonexistent)
+++ rtl/embedded/arm/samd20j18.pp	(working copy)
@@ -0,0 +1,685 @@
+unit samd20j18;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD20J18 Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD20J18 System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD20J18 Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD20J18 Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD20J18 External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD20J18 Non-Volatile Memory Controller (NVMCTRL) 
+    EVSYS_IRQn  = 6,                   //   6 SAMD20J18 Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 7,                  //   7 SAMD20J18 Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 8,                  //   8 SAMD20J18 Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 9,                  //   9 SAMD20J18 Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 10,                 //  10 SAMD20J18 Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 11,                 //  11 SAMD20J18 Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 12,                 //  12 SAMD20J18 Serial Communication Interface 5 (SERCOM5) 
+    TC0_IRQn    = 13,                  //  13 SAMD20J18 Basic Timer Counter 0 (TC0) 
+    TC1_IRQn    = 14,                  //  14 SAMD20J18 Basic Timer Counter 1 (TC1) 
+    TC2_IRQn    = 15,                  //  15 SAMD20J18 Basic Timer Counter 2 (TC2) 
+    TC3_IRQn    = 16,                  //  16 SAMD20J18 Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 17,                  //  17 SAMD20J18 Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 18,                  //  18 SAMD20J18 Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 19,                  //  19 SAMD20J18 Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 20,                  //  20 SAMD20J18 Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 21,                  //  21 SAMD20J18 Analog Digital Converter (ADC) 
+    AC_IRQn     = 22,                  //  22 SAMD20J18 Analog Comparators (AC) 
+    DAC_IRQn    = 23,                  //  23 SAMD20J18 Digital Analog Converter (DAC) 
+    PTC_IRQn    = 24                   //  24 SAMD20J18 Peripheral Touch Controller (PTC) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Inputs Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..211] of byte;
+    DCFG        : array[0..1] of longword; // Device Configuration 
+    Reserved3   : array[0..3847] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved4   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    PID5        : longword;            // Peripheral Identification 5 
+    PID6        : longword;            // Peripheral Identification 6 
+    PID7        : longword;            // Peripheral Identification 7 
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    DBGCTRL     : byte;                // I2CM Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // I2CM Baud Rate 
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : byte;                // I2CM Address 
+    Reserved4   : array[0..2] of byte;
+    DATA        : byte;                // I2CM Data 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    Reserved3   : array[0..1] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    DBGCTRL     : byte;                // SPI Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..0] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    Reserved4   : array[0..1] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : word;                // SPI Data 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    DBGCTRL     : byte;                // USART Debug Control 
+    Reserved1   : array[0..0] of byte;
+    BAUD        : word;                // USART Baud 
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved2   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    Reserved3   : array[0..5] of byte;
+    DATA        : word;                // USART Data 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // XOSC Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // XOSC32K Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // OSC32K Control 
+    OSCULP32K   : byte;                // OSCULP32K Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // OSC8M Control A 
+    DFLLCTRL    : word;                // DFLL Config 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL Calibration Value 
+    DFLLMUL     : longword;            // DFLL Multiplier 
+    DFLLSYNC    : byte;                // DFLL Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // VREG Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // VREF Control A 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC0_BASE      = $42002000;
+  TC1_BASE      = $42002400;
+  TC2_BASE      = $42002800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC0           : TTc_Registers absolute TC0_BASE;
+  TC1           : TTc_Registers absolute TC1_BASE;
+  TC2           : TTc_Registers absolute TC2_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TC0_interrupt; external name 'TC0_interrupt';
+procedure TC1_interrupt; external name 'TC1_interrupt';
+procedure TC2_interrupt; external name 'TC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TC0_interrupt
+  .long TC1_interrupt
+  .long TC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TC0_interrupt
+  .weak TC1_interrupt
+  .weak TC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TC0_interrupt, Haltproc
+  .set TC1_interrupt, Haltproc
+  .set TC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e15a.pp
===================================================================
--- rtl/embedded/arm/samd21e15a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e15a.pp	(working copy)
@@ -0,0 +1,951 @@
+unit samd21e15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E15A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E15A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E15A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E15A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E15A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E15A Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E15A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E15A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E15A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E15A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E15A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E15A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E15A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E15A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e15b.pp
===================================================================
--- rtl/embedded/arm/samd21e15b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e15b.pp	(working copy)
@@ -0,0 +1,952 @@
+unit samd21e15b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E15B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E15B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E15B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E15B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E15B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E15B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E15B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E15B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E15B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E15B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E15B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E15B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E15B Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E15B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E15B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E15B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E15B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E15B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E15B Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E15B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E15B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E15B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E15B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E15B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e15bu.pp
===================================================================
--- rtl/embedded/arm/samd21e15bu.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e15bu.pp	(working copy)
@@ -0,0 +1,952 @@
+unit samd21e15bu;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E15BU Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E15BU System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E15BU Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E15BU Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E15BU External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E15BU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E15BU Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E15BU Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E15BU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E15BU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E15BU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E15BU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E15BU Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E15BU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E15BU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E15BU Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E15BU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E15BU Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E15BU Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E15BU Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E15BU Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E15BU Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E15BU Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E15BU Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e15l.pp
===================================================================
--- rtl/embedded/arm/samd21e15l.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e15l.pp	(working copy)
@@ -0,0 +1,812 @@
+unit samd21e15l;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E15L Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E15L System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E15L Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E15L Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E15L External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E15L Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E15L Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E15L Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E15L Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E15L Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E15L Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E15L Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E15L Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E15L Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E15L Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E15L Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E15L Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E15L Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E15L Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E15L Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E15L Digital Analog Converter (DAC) 
+    AC1_IRQn    = 28                   //  28 SAMD21E15L Analog Comparators 1 (AC1) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  AC1_BASE      = $42005400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  AC1           : TAc_Registers absolute AC1_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure AC1_interrupt; external name 'AC1_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long 0
+  .long 0
+  .long AC1_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak AC1_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set AC1_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e16a.pp
===================================================================
--- rtl/embedded/arm/samd21e16a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e16a.pp	(working copy)
@@ -0,0 +1,951 @@
+unit samd21e16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E16A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E16A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E16A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E16A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E16A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E16A Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E16A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E16A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E16A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E16A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E16A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E16A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E16A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E16A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e16b.pp
===================================================================
--- rtl/embedded/arm/samd21e16b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e16b.pp	(working copy)
@@ -0,0 +1,952 @@
+unit samd21e16b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E16B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E16B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E16B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E16B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E16B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E16B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E16B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E16B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E16B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E16B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E16B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E16B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E16B Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E16B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E16B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E16B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E16B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E16B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E16B Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E16B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E16B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E16B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E16B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E16B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e16bu.pp
===================================================================
--- rtl/embedded/arm/samd21e16bu.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e16bu.pp	(working copy)
@@ -0,0 +1,952 @@
+unit samd21e16bu;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E16BU Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E16BU System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E16BU Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E16BU Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E16BU External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E16BU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E16BU Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E16BU Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E16BU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E16BU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E16BU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E16BU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E16BU Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E16BU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E16BU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E16BU Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E16BU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E16BU Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E16BU Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E16BU Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E16BU Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E16BU Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E16BU Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E16BU Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e16l.pp
===================================================================
--- rtl/embedded/arm/samd21e16l.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e16l.pp	(working copy)
@@ -0,0 +1,812 @@
+unit samd21e16l;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E16L Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E16L System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E16L Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E16L Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E16L External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E16L Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E16L Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E16L Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E16L Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E16L Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E16L Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E16L Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E16L Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E16L Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E16L Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E16L Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E16L Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E16L Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E16L Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E16L Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E16L Digital Analog Converter (DAC) 
+    AC1_IRQn    = 28                   //  28 SAMD21E16L Analog Comparators 1 (AC1) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  AC1_BASE      = $42005400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  AC1           : TAc_Registers absolute AC1_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure AC1_interrupt; external name 'AC1_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long 0
+  .long 0
+  .long AC1_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak AC1_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set AC1_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e17a.pp
===================================================================
--- rtl/embedded/arm/samd21e17a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e17a.pp	(working copy)
@@ -0,0 +1,951 @@
+unit samd21e17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E17A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E17A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E17A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E17A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E17A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E17A Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E17A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E17A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E17A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E17A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E17A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E17A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E17A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E17A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21e18a.pp
===================================================================
--- rtl/embedded/arm/samd21e18a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21e18a.pp	(working copy)
@@ -0,0 +1,951 @@
+unit samd21e18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21E18A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21E18A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21E18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21E18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21E18A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21E18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21E18A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21E18A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21E18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21E18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21E18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21E18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21E18A Serial Communication Interface 3 (SERCOM3) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21E18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21E18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21E18A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21E18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21E18A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21E18A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21E18A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21E18A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21E18A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21E18A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21E18A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long 0
+  .long 0
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g15a.pp
===================================================================
--- rtl/embedded/arm/samd21g15a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g15a.pp	(working copy)
@@ -0,0 +1,963 @@
+unit samd21g15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G15A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G15A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G15A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G15A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G15A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G15A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G15A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G15A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G15A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G15A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G15A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G15A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G15A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G15A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G15A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G15A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g15b.pp
===================================================================
--- rtl/embedded/arm/samd21g15b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g15b.pp	(working copy)
@@ -0,0 +1,964 @@
+unit samd21g15b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G15B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G15B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G15B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G15B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G15B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G15B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G15B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G15B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G15B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G15B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G15B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G15B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G15B Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G15B Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G15B Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G15B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G15B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G15B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G15B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G15B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G15B Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G15B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G15B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G15B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G15B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G15B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g15l.pp
===================================================================
--- rtl/embedded/arm/samd21g15l.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g15l.pp	(working copy)
@@ -0,0 +1,836 @@
+unit samd21g15l;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G15L Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G15L System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G15L Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G15L Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G15L External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G15L Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G15L Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G15L Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G15L Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G15L Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G15L Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G15L Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G15L Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G15L Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G15L Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G15L Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G15L Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G15L Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G15L Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G15L Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21G15L Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21G15L Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G15L Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G15L Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G15L Digital Analog Converter (DAC) 
+    AC1_IRQn    = 28                   //  28 SAMD21G15L Analog Comparators 1 (AC1) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  AC1_BASE      = $42005400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  AC1           : TAc_Registers absolute AC1_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure AC1_interrupt; external name 'AC1_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long 0
+  .long 0
+  .long AC1_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak AC1_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set AC1_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g16a.pp
===================================================================
--- rtl/embedded/arm/samd21g16a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g16a.pp	(working copy)
@@ -0,0 +1,963 @@
+unit samd21g16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G16A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G16A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G16A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G16A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G16A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G16A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G16A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G16A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G16A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G16A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G16A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G16A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G16A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G16A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G16A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G16A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g16b.pp
===================================================================
--- rtl/embedded/arm/samd21g16b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g16b.pp	(working copy)
@@ -0,0 +1,964 @@
+unit samd21g16b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G16B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G16B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G16B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G16B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G16B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G16B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G16B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G16B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G16B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G16B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G16B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G16B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G16B Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G16B Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G16B Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G16B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G16B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G16B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G16B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G16B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G16B Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G16B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G16B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G16B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G16B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G16B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g16l.pp
===================================================================
--- rtl/embedded/arm/samd21g16l.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g16l.pp	(working copy)
@@ -0,0 +1,836 @@
+unit samd21g16l;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G16L Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G16L System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G16L Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G16L Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G16L External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G16L Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G16L Direct Memory Access Controller (DMAC) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G16L Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G16L Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G16L Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G16L Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G16L Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G16L Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G16L Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G16L Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G16L Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G16L Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G16L Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G16L Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G16L Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21G16L Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21G16L Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G16L Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G16L Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G16L Digital Analog Converter (DAC) 
+    AC1_IRQn    = 28                   //  28 SAMD21G16L Analog Comparators 1 (AC1) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  AC1_BASE      = $42005400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  AC1           : TAc_Registers absolute AC1_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure AC1_interrupt; external name 'AC1_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long 0
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long 0
+  .long 0
+  .long AC1_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak AC1_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set AC1_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g17a.pp
===================================================================
--- rtl/embedded/arm/samd21g17a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g17a.pp	(working copy)
@@ -0,0 +1,963 @@
+unit samd21g17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G17A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G17A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G17A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G17A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G17A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G17A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G17A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G17A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G17A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G17A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G17A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G17A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G17A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G17A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G17A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G17A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g17au.pp
===================================================================
--- rtl/embedded/arm/samd21g17au.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g17au.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21g17au;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G17AU Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G17AU System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G17AU Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G17AU Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G17AU External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G17AU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G17AU Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G17AU Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G17AU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G17AU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G17AU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G17AU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G17AU Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G17AU Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G17AU Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G17AU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G17AU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G17AU Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G17AU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G17AU Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G17AU Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21G17AU Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21G17AU Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G17AU Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G17AU Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G17AU Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G17AU Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G17AU Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g18a.pp
===================================================================
--- rtl/embedded/arm/samd21g18a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g18a.pp	(working copy)
@@ -0,0 +1,963 @@
+unit samd21g18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G18A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G18A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G18A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G18A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G18A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G18A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G18A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G18A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G18A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G18A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G18A Basic Timer Counter 5 (TC5) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G18A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G18A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G18A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G18A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G18A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long 0
+  .long 0
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21g18au.pp
===================================================================
--- rtl/embedded/arm/samd21g18au.pp	(nonexistent)
+++ rtl/embedded/arm/samd21g18au.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21g18au;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21G18AU Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21G18AU System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21G18AU Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21G18AU Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21G18AU External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21G18AU Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21G18AU Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21G18AU Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21G18AU Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21G18AU Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21G18AU Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21G18AU Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21G18AU Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21G18AU Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21G18AU Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21G18AU Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21G18AU Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21G18AU Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21G18AU Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21G18AU Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21G18AU Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21G18AU Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21G18AU Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21G18AU Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21G18AU Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21G18AU Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21G18AU Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21G18AU Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j15a.pp
===================================================================
--- rtl/embedded/arm/samd21j15a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j15a.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21j15a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J15A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J15A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J15A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J15A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J15A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J15A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J15A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J15A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J15A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J15A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J15A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J15A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J15A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J15A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J15A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J15A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J15A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J15A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J15A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J15A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J15A Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J15A Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J15A Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J15A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J15A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J15A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J15A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J15A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j15b.pp
===================================================================
--- rtl/embedded/arm/samd21j15b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j15b.pp	(working copy)
@@ -0,0 +1,976 @@
+unit samd21j15b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J15B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J15B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J15B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J15B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J15B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J15B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J15B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J15B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J15B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J15B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J15B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J15B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J15B Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J15B Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J15B Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J15B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J15B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J15B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J15B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J15B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J15B Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J15B Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J15B Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J15B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J15B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J15B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J15B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J15B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j16a.pp
===================================================================
--- rtl/embedded/arm/samd21j16a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j16a.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21j16a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J16A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J16A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J16A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J16A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J16A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J16A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J16A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J16A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J16A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J16A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J16A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J16A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J16A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J16A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J16A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J16A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J16A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J16A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J16A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J16A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J16A Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J16A Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J16A Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J16A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J16A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J16A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J16A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J16A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j16b.pp
===================================================================
--- rtl/embedded/arm/samd21j16b.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j16b.pp	(working copy)
@@ -0,0 +1,976 @@
+unit samd21j16b;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J16B Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J16B System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J16B Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J16B Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J16B External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J16B Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J16B Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J16B Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J16B Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J16B Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J16B Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J16B Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J16B Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J16B Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J16B Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J16B Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J16B Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J16B Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J16B Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J16B Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J16B Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J16B Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J16B Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J16B Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J16B Analog Comparators  (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J16B Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J16B Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J16B Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Transfer Source Address 
+    DSTADDR     : longword;            // Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    EXTCTRL     : byte;                // External Reset Controller 
+    Reserved1   : array[0..4] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Synchronization Busy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Synchronization Busy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Synchronization Busy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j17a.pp
===================================================================
--- rtl/embedded/arm/samd21j17a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j17a.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21j17a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J17A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J17A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J17A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J17A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J17A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J17A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J17A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J17A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J17A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J17A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J17A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J17A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J17A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J17A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J17A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J17A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J17A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J17A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J17A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J17A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J17A Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J17A Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J17A Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J17A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J17A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J17A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J17A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J17A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
Index: rtl/embedded/arm/samd21j18a.pp
===================================================================
--- rtl/embedded/arm/samd21j18a.pp	(nonexistent)
+++ rtl/embedded/arm/samd21j18a.pp	(working copy)
@@ -0,0 +1,975 @@
+unit samd21j18a;
+interface
+{$PACKRECORDS C}
+{$GOTO ON}
+
+type
+  TIRQn_Enum = (
+    NonMaskableInt_IRQn = -14,         //   2 Non Maskable Interrupt                 
+    HardFault_IRQn = -13,              //   3 Cortex-M0+ Hard Fault Interrupt        
+    SVCall_IRQn = -5,                  //  11 Cortex-M0+ SV Call Interrupt           
+    PendSV_IRQn = -2,                  //  14 Cortex-M0+ Pend SV Interrupt           
+    SysTick_IRQn = -1,                 //  15 Cortex-M0+ System Tick Interrupt       
+    PM_IRQn     = 0,                   //   0 SAMD21J18A Power Manager (PM) 
+    SYSCTRL_IRQn = 1,                  //   1 SAMD21J18A System Control (SYSCTRL) 
+    WDT_IRQn    = 2,                   //   2 SAMD21J18A Watchdog Timer (WDT) 
+    RTC_IRQn    = 3,                   //   3 SAMD21J18A Real-Time Counter (RTC) 
+    EIC_IRQn    = 4,                   //   4 SAMD21J18A External Interrupt Controller (EIC) 
+    NVMCTRL_IRQn = 5,                  //   5 SAMD21J18A Non-Volatile Memory Controller (NVMCTRL) 
+    DMAC_IRQn   = 6,                   //   6 SAMD21J18A Direct Memory Access Controller (DMAC) 
+    USB_IRQn    = 7,                   //   7 SAMD21J18A Universal Serial Bus (USB) 
+    EVSYS_IRQn  = 8,                   //   8 SAMD21J18A Event System Interface (EVSYS) 
+    SERCOM0_IRQn = 9,                  //   9 SAMD21J18A Serial Communication Interface 0 (SERCOM0) 
+    SERCOM1_IRQn = 10,                 //  10 SAMD21J18A Serial Communication Interface 1 (SERCOM1) 
+    SERCOM2_IRQn = 11,                 //  11 SAMD21J18A Serial Communication Interface 2 (SERCOM2) 
+    SERCOM3_IRQn = 12,                 //  12 SAMD21J18A Serial Communication Interface 3 (SERCOM3) 
+    SERCOM4_IRQn = 13,                 //  13 SAMD21J18A Serial Communication Interface 4 (SERCOM4) 
+    SERCOM5_IRQn = 14,                 //  14 SAMD21J18A Serial Communication Interface 5 (SERCOM5) 
+    TCC0_IRQn   = 15,                  //  15 SAMD21J18A Timer Counter Control 0 (TCC0) 
+    TCC1_IRQn   = 16,                  //  16 SAMD21J18A Timer Counter Control 1 (TCC1) 
+    TCC2_IRQn   = 17,                  //  17 SAMD21J18A Timer Counter Control 2 (TCC2) 
+    TC3_IRQn    = 18,                  //  18 SAMD21J18A Basic Timer Counter 3 (TC3) 
+    TC4_IRQn    = 19,                  //  19 SAMD21J18A Basic Timer Counter 4 (TC4) 
+    TC5_IRQn    = 20,                  //  20 SAMD21J18A Basic Timer Counter 5 (TC5) 
+    TC6_IRQn    = 21,                  //  21 SAMD21J18A Basic Timer Counter 6 (TC6) 
+    TC7_IRQn    = 22,                  //  22 SAMD21J18A Basic Timer Counter 7 (TC7) 
+    ADC_IRQn    = 23,                  //  23 SAMD21J18A Analog Digital Converter (ADC) 
+    AC_IRQn     = 24,                  //  24 SAMD21J18A Analog Comparators (AC) 
+    DAC_IRQn    = 25,                  //  25 SAMD21J18A Digital Analog Converter (DAC) 
+    PTC_IRQn    = 26,                  //  26 SAMD21J18A Peripheral Touch Controller (PTC) 
+    I2S_IRQn    = 27                   //  27 SAMD21J18A Inter-IC Sound Interface (I2S) 
+  );
+
+  TAc_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    STATUSC     : byte;                // Status C 
+    Reserved2   : array[0..0] of byte;
+    WINCTRL     : byte;                // Window Control 
+    Reserved3   : array[0..2] of byte;
+    COMPCTRL    : array[0..1] of longword; // Comparator Control n 
+    Reserved4   : array[0..7] of byte;
+    SCALER      : array[0..1] of byte; // Scaler n 
+  end;
+
+  TAdc_Registers = record
+    CTRLA       : byte;                // Control A 
+    REFCTRL     : byte;                // Reference Control 
+    AVGCTRL     : byte;                // Average Control 
+    SAMPCTRL    : byte;                // Sampling Time Control 
+    CTRLB       : word;                // Control B 
+    Reserved1   : array[0..1] of byte;
+    WINCTRL     : byte;                // Window Monitor Control 
+    Reserved2   : array[0..2] of byte;
+    SWTRIG      : byte;                // Software Trigger 
+    Reserved3   : array[0..2] of byte;
+    INPUTCTRL   : longword;            // Input Control 
+    EVCTRL      : byte;                // Event Control 
+    Reserved4   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    RESULT      : word;                // Result 
+    WINLT       : word;                // Window Monitor Lower Threshold 
+    Reserved5   : array[0..1] of byte;
+    WINUT       : word;                // Window Monitor Upper Threshold 
+    Reserved6   : array[0..1] of byte;
+    GAINCORR    : word;                // Gain Correction 
+    OFFSETCORR  : word;                // Offset Correction 
+    CALIB       : word;                // Calibration 
+    DBGCTRL     : byte;                // Debug Control 
+  end;
+
+  TDac_Registers = record
+    CTRLA       : byte;                // Control A 
+    CTRLB       : byte;                // Control B 
+    EVCTRL      : byte;                // Event Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    DATA        : word;                // Data 
+    Reserved2   : array[0..1] of byte;
+    DATABUF     : word;                // Data Buffer 
+  end;
+
+  TDmac_Registers = record
+    CTRL        : word;                // Control 
+    CRCCTRL     : word;                // CRC Control 
+    CRCDATAIN   : longword;            // CRC Data Input 
+    CRCCHKSUM   : longword;            // CRC Checksum 
+    CRCSTATUS   : byte;                // CRC Status 
+    DBGCTRL     : byte;                // Debug Control 
+    QOSCTRL     : byte;                // QOS Control 
+    Reserved1   : array[0..0] of byte;
+    SWTRIGCTRL  : longword;            // Software Trigger Control 
+    PRICTRL0    : longword;            // Priority Control 0 
+    Reserved2   : array[0..7] of byte;
+    INTPEND     : word;                // Interrupt Pending 
+    Reserved3   : array[0..1] of byte;
+    INTSTATUS   : longword;            // Interrupt Status 
+    BUSYCH      : longword;            // Busy Channels 
+    PENDCH      : longword;            // Pending Channels 
+    ACTIVE      : longword;            // Active Channel and Levels 
+    BASEADDR    : longword;            // Descriptor Memory Section Base Address 
+    WRBADDR     : longword;            // Write-Back Memory Section Base Address 
+    Reserved4   : array[0..2] of byte;
+    CHID        : byte;                // Channel ID 
+    CHCTRLA     : byte;                // Channel Control A 
+    Reserved5   : array[0..2] of byte;
+    CHCTRLB     : longword;            // Channel Control B 
+    Reserved6   : array[0..3] of byte;
+    CHINTENCLR  : byte;                // Channel Interrupt Enable Clear 
+    CHINTENSET  : byte;                // Channel Interrupt Enable Set 
+    CHINTFLAG   : byte;                // Channel Interrupt Flag Status and Clear 
+    CHSTATUS    : byte;                // Channel Status 
+  end;
+
+  TDmacDescriptor_Registers = record
+    BTCTRL      : word;                // Block Transfer Control 
+    BTCNT       : word;                // Block Transfer Count 
+    SRCADDR     : longword;            // Block Transfer Source Address 
+    DSTADDR     : longword;            // Block Transfer Destination Address 
+    DESCADDR    : longword;            // Next Descriptor Address 
+  end;
+
+  TDsu_Registers = record
+    CTRL        : byte;                // Control 
+    STATUSA     : byte;                // Status A 
+    STATUSB     : byte;                // Status B 
+    Reserved1   : array[0..0] of byte;
+    ADDR        : longword;            // Address 
+    LENGTH      : longword;            // Length 
+    DATA        : longword;            // Data 
+    DCC         : array[0..1] of longword; // Debug Communication Channel n 
+    DID         : longword;            // Device Identification 
+    Reserved2   : array[0..4067] of byte;
+    ENTRY       : array[0..1] of longword; // Coresight ROM Table Entry n 
+    &END        : longword;            // Coresight ROM Table End 
+    Reserved3   : array[0..4031] of byte;
+    MEMTYPE     : longword;            // Coresight ROM Table Memory Type 
+    PID4        : longword;            // Peripheral Identification 4 
+    Reserved4   : array[0..11] of byte;
+    PID0        : longword;            // Peripheral Identification 0 
+    PID1        : longword;            // Peripheral Identification 1 
+    PID2        : longword;            // Peripheral Identification 2 
+    PID3        : longword;            // Peripheral Identification 3 
+    CID0        : longword;            // Component Identification 0 
+    CID1        : longword;            // Component Identification 1 
+    CID2        : longword;            // Component Identification 2 
+    CID3        : longword;            // Component Identification 3 
+  end;
+
+  TEic_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    NMICTRL     : byte;                // Non-Maskable Interrupt Control 
+    NMIFLAG     : byte;                // Non-Maskable Interrupt Flag Status and Clear 
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    WAKEUP      : longword;            // Wake-Up Enable 
+    CONFIG      : array[0..1] of longword; // Configuration n 
+  end;
+
+  TEvsys_Registers = record
+    CTRL        : byte;                // Control 
+    Reserved1   : array[0..2] of byte;
+    CHANNEL     : longword;            // Channel 
+    USER        : word;                // User Multiplexer 
+    Reserved2   : array[0..1] of byte;
+    CHSTATUS    : longword;            // Channel Status 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+  end;
+
+  TGclk_Registers = record
+    CTRL        : byte;                // Control 
+    STATUS      : byte;                // Status 
+    CLKCTRL     : word;                // Generic Clock Control 
+    GENCTRL     : longword;            // Generic Clock Generator Control 
+    GENDIV      : longword;            // Generic Clock Generator Division 
+  end;
+
+  THmatrixbPrs_Registers = record
+    PRAS        : longword;            // Priority A for Slave 
+    PRBS        : longword;            // Priority B for Slave 
+  end;
+
+  THmatrixb_Registers = record
+    Reserved1   : array[0..127] of byte;
+    Prs         : array[0..15] of THmatrixbPrs_Registers; // HmatrixbPrs groups 
+    Reserved2   : array[0..15] of byte;
+    SFR         : array[0..15] of longword; // Special Function 
+  end;
+
+  TI2s_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..2] of byte;
+    CLKCTRL     : array[0..1] of longword; // Clock Unit n Control 
+    INTENCLR    : word;                // Interrupt Enable Clear 
+    Reserved2   : array[0..1] of byte;
+    INTENSET    : word;                // Interrupt Enable Set 
+    Reserved3   : array[0..1] of byte;
+    INTFLAG     : word;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..1] of byte;
+    SYNCBUSY    : word;                // Synchronization Status 
+    Reserved5   : array[0..5] of byte;
+    SERCTRL     : array[0..1] of longword; // Serializer n Control 
+    Reserved6   : array[0..7] of byte;
+    DATA        : array[0..1] of longword; // Data n 
+  end;
+
+  TMtb_Registers = record
+    POSITION    : longword;            // MTB Position 
+    MASTER      : longword;            // MTB Master 
+    FLOW        : longword;            // MTB Flow 
+    BASE        : longword;            // MTB Base 
+    Reserved1   : array[0..3823] of byte;
+    ITCTRL      : longword;            // MTB Integration Mode Control 
+    Reserved2   : array[0..155] of byte;
+    CLAIMSET    : longword;            // MTB Claim Set 
+    CLAIMCLR    : longword;            // MTB Claim Clear 
+    Reserved3   : array[0..7] of byte;
+    LOCKACCESS  : longword;            // MTB Lock Access 
+    LOCKSTATUS  : longword;            // MTB Lock Status 
+    AUTHSTATUS  : longword;            // MTB Authentication Status 
+    DEVARCH     : longword;            // MTB Device Architecture 
+    Reserved4   : array[0..7] of byte;
+    DEVID       : longword;            // MTB Device Configuration 
+    DEVTYPE     : longword;            // MTB Device Type 
+    PID4        : longword;            // CoreSight 
+    PID5        : longword;            // CoreSight 
+    PID6        : longword;            // CoreSight 
+    PID7        : longword;            // CoreSight 
+    PID0        : longword;            // CoreSight 
+    PID1        : longword;            // CoreSight 
+    PID2        : longword;            // CoreSight 
+    PID3        : longword;            // CoreSight 
+    CID0        : longword;            // CoreSight 
+    CID1        : longword;            // CoreSight 
+    CID2        : longword;            // CoreSight 
+    CID3        : longword;            // CoreSight 
+  end;
+
+  TNvmctrl_Registers = record
+    CTRLA       : word;                // Control A 
+    Reserved1   : array[0..1] of byte;
+    CTRLB       : longword;            // Control B 
+    PARAM       : longword;            // NVM Parameter 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    Reserved2   : array[0..2] of byte;
+    INTENSET    : byte;                // Interrupt Enable Set 
+    Reserved3   : array[0..2] of byte;
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..2] of byte;
+    STATUS      : word;                // Status 
+    Reserved5   : array[0..1] of byte;
+    ADDR        : longword;            // Address 
+    LOCK        : word;                // Lock Section 
+  end;
+
+  TPac_Registers = record
+    WPCLR       : longword;            // Write Protection Clear 
+    WPSET       : longword;            // Write Protection Set 
+  end;
+
+  TPm_Registers = record
+    CTRL        : byte;                // Control 
+    SLEEP       : byte;                // Sleep Mode 
+    Reserved1   : array[0..5] of byte;
+    CPUSEL      : byte;                // CPU Clock Select 
+    APBASEL     : byte;                // APBA Clock Select 
+    APBBSEL     : byte;                // APBB Clock Select 
+    APBCSEL     : byte;                // APBC Clock Select 
+    Reserved2   : array[0..7] of byte;
+    AHBMASK     : longword;            // AHB Mask 
+    APBAMASK    : longword;            // APBA Mask 
+    APBBMASK    : longword;            // APBB Mask 
+    APBCMASK    : longword;            // APBC Mask 
+    Reserved3   : array[0..15] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    RCAUSE      : byte;                // Reset Cause 
+  end;
+
+  TPortGroup_Registers = record
+    DIR         : longword;            // Data Direction 
+    DIRCLR      : longword;            // Data Direction Clear 
+    DIRSET      : longword;            // Data Direction Set 
+    DIRTGL      : longword;            // Data Direction Toggle 
+    OUT         : longword;            // Data Output Value 
+    OUTCLR      : longword;            // Data Output Value Clear 
+    OUTSET      : longword;            // Data Output Value Set 
+    OUTTGL      : longword;            // Data Output Value Toggle 
+    &IN         : longword;            // Data Input Value 
+    CTRL        : longword;            // Control 
+    WRCONFIG    : longword;            // Write Configuration 
+    Reserved1   : array[0..3] of byte;
+    PMUX        : array[0..15] of byte; // Peripheral Multiplexing n 
+    PINCFG      : array[0..31] of byte; // Pin Configuration n 
+    Reserved2   : array[0..31] of byte;
+  end;
+
+  TPort_Registers = record
+    Group       : array[0..1] of TPortGroup_Registers; // PortGroup groups [GROUPS] 
+  end;
+
+  TRtcMode2Alarm_Registers = record
+    ALARM       : longword;            // MODE2_ALARM Alarm n Value 
+    MASK        : byte;                // MODE2_ALARM Alarm n Mask 
+    Reserved1   : array[0..2] of byte;
+  end;
+
+  TRtcMode0_Registers = record
+    CTRL        : word;                // MODE0 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE0 Event Control 
+    INTENCLR    : byte;                // MODE0 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE0 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE0 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : longword;            // MODE0 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    COMP        : array[0..0] of longword; // MODE0 Compare n Value 
+  end;
+
+  TRtcMode1_Registers = record
+    CTRL        : word;                // MODE1 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE1 Event Control 
+    INTENCLR    : byte;                // MODE1 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE1 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE1 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    COUNT       : word;                // MODE1 Counter Value 
+    Reserved3   : array[0..1] of byte;
+    PER         : word;                // MODE1 Counter Period 
+    Reserved4   : array[0..1] of byte;
+    COMP        : array[0..1] of word; // MODE1 Compare n Value 
+  end;
+
+  TRtcMode2_Registers = record
+    CTRL        : word;                // MODE2 Control 
+    READREQ     : word;                // Read Request 
+    EVCTRL      : word;                // MODE2 Event Control 
+    INTENCLR    : byte;                // MODE2 Interrupt Enable Clear 
+    INTENSET    : byte;                // MODE2 Interrupt Enable Set 
+    INTFLAG     : byte;                // MODE2 Interrupt Flag Status and Clear 
+    Reserved1   : array[0..0] of byte;
+    STATUS      : byte;                // Status 
+    DBGCTRL     : byte;                // Debug Control 
+    FREQCORR    : byte;                // Frequency Correction 
+    Reserved2   : array[0..2] of byte;
+    CLOCK       : longword;            // MODE2 Clock Value 
+    Reserved3   : array[0..3] of byte;
+    Mode2Alarm  : array[0..0] of TRtcMode2Alarm_Registers; // RtcMode2Alarm groups [ALARM_NUM] 
+  end;
+
+  TSercomI2cm_Registers = record
+    CTRLA       : longword;            // I2CM Control A 
+    CTRLB       : longword;            // I2CM Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : longword;            // I2CM Baud Rate 
+    Reserved2   : array[0..3] of byte;
+    INTENCLR    : byte;                // I2CM Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CM Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CM Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // I2CM Status 
+    SYNCBUSY    : longword;            // I2CM Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // I2CM Address 
+    DATA        : byte;                // I2CM Data 
+    Reserved7   : array[0..6] of byte;
+    DBGCTRL     : byte;                // I2CM Debug Control 
+  end;
+
+  TSercomI2cs_Registers = record
+    CTRLA       : longword;            // I2CS Control A 
+    CTRLB       : longword;            // I2CS Control B 
+    Reserved1   : array[0..11] of byte;
+    INTENCLR    : byte;                // I2CS Interrupt Enable Clear 
+    Reserved2   : array[0..0] of byte;
+    INTENSET    : byte;                // I2CS Interrupt Enable Set 
+    Reserved3   : array[0..0] of byte;
+    INTFLAG     : byte;                // I2CS Interrupt Flag Status and Clear 
+    Reserved4   : array[0..0] of byte;
+    STATUS      : word;                // I2CS Status 
+    SYNCBUSY    : longword;            // I2CS Syncbusy 
+    Reserved5   : array[0..3] of byte;
+    ADDR        : longword;            // I2CS Address 
+    DATA        : byte;                // I2CS Data 
+  end;
+
+  TSercomSpi_Registers = record
+    CTRLA       : longword;            // SPI Control A 
+    CTRLB       : longword;            // SPI Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : byte;                // SPI Baud Rate 
+    Reserved2   : array[0..6] of byte;
+    INTENCLR    : byte;                // SPI Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // SPI Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // SPI Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // SPI Status 
+    SYNCBUSY    : longword;            // SPI Syncbusy 
+    Reserved6   : array[0..3] of byte;
+    ADDR        : longword;            // SPI Address 
+    DATA        : longword;            // SPI Data 
+    Reserved7   : array[0..3] of byte;
+    DBGCTRL     : byte;                // SPI Debug Control 
+  end;
+
+  TSercomUsart_Registers = record
+    CTRLA       : longword;            // USART Control A 
+    CTRLB       : longword;            // USART Control B 
+    Reserved1   : array[0..3] of byte;
+    BAUD        : word;                // USART Baud Rate 
+    RXPL        : byte;                // USART Receive Pulse Length 
+    Reserved2   : array[0..4] of byte;
+    INTENCLR    : byte;                // USART Interrupt Enable Clear 
+    Reserved3   : array[0..0] of byte;
+    INTENSET    : byte;                // USART Interrupt Enable Set 
+    Reserved4   : array[0..0] of byte;
+    INTFLAG     : byte;                // USART Interrupt Flag Status and Clear 
+    Reserved5   : array[0..0] of byte;
+    STATUS      : word;                // USART Status 
+    SYNCBUSY    : longword;            // USART Syncbusy 
+    Reserved6   : array[0..7] of byte;
+    DATA        : word;                // USART Data 
+    Reserved7   : array[0..5] of byte;
+    DBGCTRL     : byte;                // USART Debug Control 
+  end;
+
+  TSysctrl_Registers = record
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    PCLKSR      : longword;            // Power and Clocks Status 
+    XOSC        : word;                // External Multipurpose Crystal Oscillator (XOSC) Control 
+    Reserved1   : array[0..1] of byte;
+    XOSC32K     : word;                // 32kHz External Crystal Oscillator (XOSC32K) Control 
+    Reserved2   : array[0..1] of byte;
+    OSC32K      : longword;            // 32kHz Internal Oscillator (OSC32K) Control 
+    OSCULP32K   : byte;                // 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control 
+    Reserved3   : array[0..2] of byte;
+    OSC8M       : longword;            // 8MHz Internal Oscillator (OSC8M) Control 
+    DFLLCTRL    : word;                // DFLL48M Control 
+    Reserved4   : array[0..1] of byte;
+    DFLLVAL     : longword;            // DFLL48M Value 
+    DFLLMUL     : longword;            // DFLL48M Multiplier 
+    DFLLSYNC    : byte;                // DFLL48M Synchronization 
+    Reserved5   : array[0..2] of byte;
+    BOD33       : longword;            // 3.3V Brown-Out Detector (BOD33) Control 
+    Reserved6   : array[0..3] of byte;
+    VREG        : word;                // Voltage Regulator System (VREG) Control 
+    Reserved7   : array[0..1] of byte;
+    VREF        : longword;            // Voltage References System (VREF) Control 
+    DPLLCTRLA   : byte;                // DPLL Control A 
+    Reserved8   : array[0..2] of byte;
+    DPLLRATIO   : longword;            // DPLL Ratio Control 
+    DPLLCTRLB   : longword;            // DPLL Control B 
+    DPLLSTATUS  : byte;                // DPLL Status 
+  end;
+
+  TTcCount8_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : byte;                // COUNT8 Counter Value 
+    Reserved3   : array[0..2] of byte;
+    PER         : byte;                // COUNT8 Period Value 
+    Reserved4   : array[0..2] of byte;
+    CC          : array[0..1] of byte; // COUNT8 Compare/Capture 
+  end;
+
+  TTcCount16_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : word;                // COUNT16 Counter Value 
+    Reserved3   : array[0..5] of byte;
+    CC          : array[0..1] of word; // COUNT16 Compare/Capture 
+  end;
+
+  TTcCount32_Registers = record
+    CTRLA       : word;                // Control A 
+    READREQ     : word;                // Read Request 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    CTRLC       : byte;                // Control C 
+    Reserved1   : array[0..0] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved2   : array[0..0] of byte;
+    EVCTRL      : word;                // Event Control 
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    COUNT       : longword;            // COUNT32 Counter Value 
+    Reserved3   : array[0..3] of byte;
+    CC          : array[0..1] of longword; // COUNT32 Compare/Capture 
+  end;
+
+  TTcc_Registers = record
+    CTRLA       : longword;            // Control A 
+    CTRLBCLR    : byte;                // Control B Clear 
+    CTRLBSET    : byte;                // Control B Set 
+    Reserved1   : array[0..1] of byte;
+    SYNCBUSY    : longword;            // Synchronization Busy 
+    FCTRLA      : longword;            // Recoverable Fault A Configuration 
+    FCTRLB      : longword;            // Recoverable Fault B Configuration 
+    WEXCTRL     : longword;            // Waveform Extension Configuration 
+    DRVCTRL     : longword;            // Driver Control 
+    Reserved2   : array[0..1] of byte;
+    DBGCTRL     : byte;                // Debug Control 
+    Reserved3   : array[0..0] of byte;
+    EVCTRL      : longword;            // Event Control 
+    INTENCLR    : longword;            // Interrupt Enable Clear 
+    INTENSET    : longword;            // Interrupt Enable Set 
+    INTFLAG     : longword;            // Interrupt Flag Status and Clear 
+    STATUS      : longword;            // Status 
+    COUNT       : longword;            // Count 
+    PATT        : word;                // Pattern 
+    Reserved4   : array[0..1] of byte;
+    WAVE        : longword;            // Waveform Control 
+    PER         : longword;            // Period 
+    CC          : array[0..3] of longword; // Compare and Capture 
+    Reserved5   : array[0..15] of byte;
+    PATTB       : word;                // Pattern Buffer 
+    Reserved6   : array[0..1] of byte;
+    WAVEB       : longword;            // Waveform Control Buffer 
+    PERB        : longword;            // Period Buffer 
+    CCB         : array[0..3] of longword; // Compare and Capture Buffer 
+  end;
+
+  TUsbDeviceDescBank_Registers = record
+    ADDR        : longword;            // DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // DEVICE_DESC_BANK Endpoint Bank, Packet Size 
+    EXTREG      : word;                // DEVICE_DESC_BANK Endpoint Bank, Extended 
+    STATUS_BK   : byte;                // DEVICE_DESC_BANK Enpoint Bank, Status of Bank 
+    Reserved1   : array[0..4] of byte;
+  end;
+
+  TUsbHostDescBank_Registers = record
+    ADDR        : longword;            // HOST_DESC_BANK Host Bank, Adress of Data Buffer 
+    PCKSIZE     : longword;            // HOST_DESC_BANK Host Bank, Packet Size 
+    EXTREG      : word;                // HOST_DESC_BANK Host Bank, Extended 
+    STATUS_BK   : byte;                // HOST_DESC_BANK Host Bank, Status of Bank 
+    Reserved1   : array[0..0] of byte;
+    CTRL_PIPE   : word;                // HOST_DESC_BANK Host Bank, Host Control Pipe 
+    STATUS_PIPE : word;                // HOST_DESC_BANK Host Bank, Host Status Pipe 
+  end;
+
+  TUsbDeviceEndpoint_Registers = record
+    EPCFG       : byte;                // DEVICE_ENDPOINT End Point Configuration 
+    Reserved1   : array[0..2] of byte;
+    EPSTATUSCLR : byte;                // DEVICE_ENDPOINT End Point Pipe Status Clear 
+    EPSTATUSSET : byte;                // DEVICE_ENDPOINT End Point Pipe Status Set 
+    EPSTATUS    : byte;                // DEVICE_ENDPOINT End Point Pipe Status 
+    EPINTFLAG   : byte;                // DEVICE_ENDPOINT End Point Interrupt Flag 
+    EPINTENCLR  : byte;                // DEVICE_ENDPOINT End Point Interrupt Clear Flag 
+    EPINTENSET  : byte;                // DEVICE_ENDPOINT End Point Interrupt Set Flag 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbHostPipe_Registers = record
+    PCFG        : byte;                // HOST_PIPE End Point Configuration 
+    Reserved1   : array[0..1] of byte;
+    BINTERVAL   : byte;                // HOST_PIPE Bus Access Period of Pipe 
+    PSTATUSCLR  : byte;                // HOST_PIPE End Point Pipe Status Clear 
+    PSTATUSSET  : byte;                // HOST_PIPE End Point Pipe Status Set 
+    PSTATUS     : byte;                // HOST_PIPE End Point Pipe Status 
+    PINTFLAG    : byte;                // HOST_PIPE Pipe Interrupt Flag 
+    PINTENCLR   : byte;                // HOST_PIPE Pipe Interrupt Flag Clear 
+    PINTENSET   : byte;                // HOST_PIPE Pipe Interrupt Flag Set 
+    Reserved2   : array[0..21] of byte;
+  end;
+
+  TUsbDevice_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // DEVICE Control B 
+    DADD        : byte;                // DEVICE Device Address 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // DEVICE Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // DEVICE Device Frame Number 
+    Reserved5   : array[0..1] of byte;
+    INTENCLR    : word;                // DEVICE Device Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // DEVICE Device Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // DEVICE Device Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    EPINTSMRY   : word;                // DEVICE End Point Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    DeviceEndpoint : array[0..7] of TUsbDeviceEndpoint_Registers; // UsbDeviceEndpoint groups [EPT_NUM] 
+  end;
+
+  TUsbHost_Registers = record
+    CTRLA       : byte;                // Control A 
+    Reserved1   : array[0..0] of byte;
+    SYNCBUSY    : byte;                // Synchronization Busy 
+    QOSCTRL     : byte;                // USB Quality Of Service 
+    Reserved2   : array[0..3] of byte;
+    CTRLB       : word;                // HOST Control B 
+    HSOFC       : byte;                // HOST Host Start Of Frame Control 
+    Reserved3   : array[0..0] of byte;
+    STATUS      : byte;                // HOST Status 
+    FSMSTATUS   : byte;                // Finite State Machine Status 
+    Reserved4   : array[0..1] of byte;
+    FNUM        : word;                // HOST Host Frame Number 
+    FLENHIGH    : byte;                // HOST Host Frame Length 
+    Reserved5   : array[0..0] of byte;
+    INTENCLR    : word;                // HOST Host Interrupt Enable Clear 
+    Reserved6   : array[0..1] of byte;
+    INTENSET    : word;                // HOST Host Interrupt Enable Set 
+    Reserved7   : array[0..1] of byte;
+    INTFLAG     : word;                // HOST Host Interrupt Flag 
+    Reserved8   : array[0..1] of byte;
+    PINTSMRY    : word;                // HOST Pipe Interrupt Summary 
+    Reserved9   : array[0..1] of byte;
+    DESCADD     : longword;            // Descriptor Address 
+    PADCAL      : word;                // USB PAD Calibration 
+    Reserved10  : array[0..213] of byte;
+    HostPipe    : array[0..7] of TUsbHostPipe_Registers; // UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] 
+  end;
+
+  TUsbDeviceDescriptor_Registers = record
+    DeviceDescBank : array[0..1] of TUsbDeviceDescBank_Registers; // UsbDeviceDescBank groups 
+  end;
+
+  TUsbHostDescriptor_Registers = record
+    HostDescBank : array[0..1] of TUsbHostDescBank_Registers; // UsbHostDescBank groups [2*HOST_IMPLEMENTED] 
+  end;
+
+  TWdt_Registers = record
+    CTRL        : byte;                // Control 
+    CONFIG      : byte;                // Configuration 
+    EWCTRL      : byte;                // Early Warning Interrupt Control 
+    Reserved1   : array[0..0] of byte;
+    INTENCLR    : byte;                // Interrupt Enable Clear 
+    INTENSET    : byte;                // Interrupt Enable Set 
+    INTFLAG     : byte;                // Interrupt Flag Status and Clear 
+    STATUS      : byte;                // Status 
+    CLEAR       : byte;                // Clear 
+  end;
+
+  TRtc_Registers = record
+    case byte of
+      0: ( MODE0 : TRtcMode0_Registers );
+      1: ( MODE1 : TRtcMode1_Registers );
+      2: ( MODE2 : TRtcMode2_Registers );
+  end;
+
+  TSercom_Registers = record
+    case byte of
+      0: ( I2CM : TSercomI2cm_Registers );
+      1: ( I2CS : TSercomI2cs_Registers );
+      2: ( SPI : TSercomSpi_Registers );
+      3: ( USART : TSercomUsart_Registers );
+  end;
+
+  TTc_Registers = record
+    case byte of
+      0: ( COUNT8 : TTcCount8_Registers );
+      1: ( COUNT16 : TTcCount16_Registers );
+      2: ( COUNT32 : TTcCount32_Registers );
+  end;
+
+  TUsb_Registers = record
+    case byte of
+      0: ( DEVICE : TUsbDevice_Registers );
+      1: ( HOST : TUsbHost_Registers );
+  end;
+
+const
+  AC_BASE       = $42004400;
+  ADC_BASE      = $42004000;
+  DAC_BASE      = $42004800;
+  DMAC_BASE     = $41004800;
+  DSU_BASE      = $41002000;
+  EIC_BASE      = $40001800;
+  EVSYS_BASE    = $42000400;
+  GCLK_BASE     = $40000C00;
+  SBMATRIX_BASE = $41007000;
+  I2S_BASE      = $42005000;
+  MTB_BASE      = $41006000;
+  NVMCTRL_BASE  = $41004000;
+  PAC0_BASE     = $40000000;
+  PAC1_BASE     = $41000000;
+  PAC2_BASE     = $42000000;
+  PM_BASE       = $40000400;
+  PORT_BASE     = $41004400;
+  PORT_IOBUS_BASE= $60000000;
+  RTC_BASE      = $40001400;
+  SERCOM0_BASE  = $42000800;
+  SERCOM1_BASE  = $42000C00;
+  SERCOM2_BASE  = $42001000;
+  SERCOM3_BASE  = $42001400;
+  SERCOM4_BASE  = $42001800;
+  SERCOM5_BASE  = $42001C00;
+  SYSCTRL_BASE  = $40000800;
+  TC3_BASE      = $42002C00;
+  TC4_BASE      = $42003000;
+  TC5_BASE      = $42003400;
+  TC6_BASE      = $42003800;
+  TC7_BASE      = $42003C00;
+  TCC0_BASE     = $42002000;
+  TCC1_BASE     = $42002400;
+  TCC2_BASE     = $42002800;
+  USB_BASE      = $41005000;
+  WDT_BASE      = $40001000;
+
+var
+  AC            : TAc_Registers absolute AC_BASE;
+  ADC           : TAdc_Registers absolute ADC_BASE;
+  DAC           : TDac_Registers absolute DAC_BASE;
+  DMAC          : TDmac_Registers absolute DMAC_BASE;
+  DSU           : TDsu_Registers absolute DSU_BASE;
+  EIC           : TEic_Registers absolute EIC_BASE;
+  EVSYS         : TEvsys_Registers absolute EVSYS_BASE;
+  GCLK          : TGclk_Registers absolute GCLK_BASE;
+  SBMATRIX      : THmatrixb_Registers absolute SBMATRIX_BASE;
+  I2S           : TI2s_Registers absolute I2S_BASE;
+  MTB           : TMtb_Registers absolute MTB_BASE;
+  NVMCTRL       : TNvmctrl_Registers absolute NVMCTRL_BASE;
+  PAC0          : TPac_Registers absolute PAC0_BASE;
+  PAC1          : TPac_Registers absolute PAC1_BASE;
+  PAC2          : TPac_Registers absolute PAC2_BASE;
+  PM            : TPm_Registers absolute PM_BASE;
+  PORT          : TPort_Registers absolute PORT_BASE;
+  PORT_IOBUS    : TPort_Registers absolute PORT_IOBUS_BASE;
+  RTC           : TRtc_Registers absolute RTC_BASE;
+  SERCOM0       : TSercom_Registers absolute SERCOM0_BASE;
+  SERCOM1       : TSercom_Registers absolute SERCOM1_BASE;
+  SERCOM2       : TSercom_Registers absolute SERCOM2_BASE;
+  SERCOM3       : TSercom_Registers absolute SERCOM3_BASE;
+  SERCOM4       : TSercom_Registers absolute SERCOM4_BASE;
+  SERCOM5       : TSercom_Registers absolute SERCOM5_BASE;
+  SYSCTRL       : TSysctrl_Registers absolute SYSCTRL_BASE;
+  TC3           : TTc_Registers absolute TC3_BASE;
+  TC4           : TTc_Registers absolute TC4_BASE;
+  TC5           : TTc_Registers absolute TC5_BASE;
+  TC6           : TTc_Registers absolute TC6_BASE;
+  TC7           : TTc_Registers absolute TC7_BASE;
+  TCC0          : TTcc_Registers absolute TCC0_BASE;
+  TCC1          : TTcc_Registers absolute TCC1_BASE;
+  TCC2          : TTcc_Registers absolute TCC2_BASE;
+  USB           : TUsb_Registers absolute USB_BASE;
+  WDT           : TWdt_Registers absolute WDT_BASE;
+
+implementation
+
+procedure NonMaskableInt_interrupt; external name 'NonMaskableInt_interrupt';
+procedure HardFault_interrupt; external name 'HardFault_interrupt';
+procedure SVCall_interrupt; external name 'SVCall_interrupt';
+procedure PendSV_interrupt; external name 'PendSV_interrupt';
+procedure SysTick_interrupt; external name 'SysTick_interrupt';
+procedure PM_interrupt; external name 'PM_interrupt';
+procedure SYSCTRL_interrupt; external name 'SYSCTRL_interrupt';
+procedure WDT_interrupt; external name 'WDT_interrupt';
+procedure RTC_interrupt; external name 'RTC_interrupt';
+procedure EIC_interrupt; external name 'EIC_interrupt';
+procedure NVMCTRL_interrupt; external name 'NVMCTRL_interrupt';
+procedure DMAC_interrupt; external name 'DMAC_interrupt';
+procedure USB_interrupt; external name 'USB_interrupt';
+procedure EVSYS_interrupt; external name 'EVSYS_interrupt';
+procedure SERCOM0_interrupt; external name 'SERCOM0_interrupt';
+procedure SERCOM1_interrupt; external name 'SERCOM1_interrupt';
+procedure SERCOM2_interrupt; external name 'SERCOM2_interrupt';
+procedure SERCOM3_interrupt; external name 'SERCOM3_interrupt';
+procedure SERCOM4_interrupt; external name 'SERCOM4_interrupt';
+procedure SERCOM5_interrupt; external name 'SERCOM5_interrupt';
+procedure TCC0_interrupt; external name 'TCC0_interrupt';
+procedure TCC1_interrupt; external name 'TCC1_interrupt';
+procedure TCC2_interrupt; external name 'TCC2_interrupt';
+procedure TC3_interrupt; external name 'TC3_interrupt';
+procedure TC4_interrupt; external name 'TC4_interrupt';
+procedure TC5_interrupt; external name 'TC5_interrupt';
+procedure TC6_interrupt; external name 'TC6_interrupt';
+procedure TC7_interrupt; external name 'TC7_interrupt';
+procedure ADC_interrupt; external name 'ADC_interrupt';
+procedure AC_interrupt; external name 'AC_interrupt';
+procedure DAC_interrupt; external name 'DAC_interrupt';
+procedure PTC_interrupt; external name 'PTC_interrupt';
+procedure I2S_interrupt; external name 'I2S_interrupt';
+
+
+{$i cortexm0_start.inc}
+
+procedure Vectors; assembler; nostackframe;
+label interrupt_vectors;
+asm
+  .section ".init.interrupt_vectors"
+  interrupt_vectors:
+  .long _stack_top
+  .long Startup
+  .long NonMaskableInt_interrupt
+  .long HardFault_interrupt
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long 0
+  .long SVCall_interrupt
+  .long 0
+  .long 0
+  .long PendSV_interrupt
+  .long SysTick_interrupt
+  .long PM_interrupt
+  .long SYSCTRL_interrupt
+  .long WDT_interrupt
+  .long RTC_interrupt
+  .long EIC_interrupt
+  .long NVMCTRL_interrupt
+  .long DMAC_interrupt
+  .long USB_interrupt
+  .long EVSYS_interrupt
+  .long SERCOM0_interrupt
+  .long SERCOM1_interrupt
+  .long SERCOM2_interrupt
+  .long SERCOM3_interrupt
+  .long SERCOM4_interrupt
+  .long SERCOM5_interrupt
+  .long TCC0_interrupt
+  .long TCC1_interrupt
+  .long TCC2_interrupt
+  .long TC3_interrupt
+  .long TC4_interrupt
+  .long TC5_interrupt
+  .long TC6_interrupt
+  .long TC7_interrupt
+  .long ADC_interrupt
+  .long AC_interrupt
+  .long DAC_interrupt
+  .long PTC_interrupt
+  .long I2S_interrupt
+
+  .weak NonMaskableInt_interrupt
+  .weak HardFault_interrupt
+  .weak SVCall_interrupt
+  .weak PendSV_interrupt
+  .weak SysTick_interrupt
+  .weak PM_interrupt
+  .weak SYSCTRL_interrupt
+  .weak WDT_interrupt
+  .weak RTC_interrupt
+  .weak EIC_interrupt
+  .weak NVMCTRL_interrupt
+  .weak DMAC_interrupt
+  .weak USB_interrupt
+  .weak EVSYS_interrupt
+  .weak SERCOM0_interrupt
+  .weak SERCOM1_interrupt
+  .weak SERCOM2_interrupt
+  .weak SERCOM3_interrupt
+  .weak SERCOM4_interrupt
+  .weak SERCOM5_interrupt
+  .weak TCC0_interrupt
+  .weak TCC1_interrupt
+  .weak TCC2_interrupt
+  .weak TC3_interrupt
+  .weak TC4_interrupt
+  .weak TC5_interrupt
+  .weak TC6_interrupt
+  .weak TC7_interrupt
+  .weak ADC_interrupt
+  .weak AC_interrupt
+  .weak DAC_interrupt
+  .weak PTC_interrupt
+  .weak I2S_interrupt
+
+  .set NonMaskableInt_interrupt, Haltproc
+  .set HardFault_interrupt, Haltproc
+  .set SVCall_interrupt, Haltproc
+  .set PendSV_interrupt, Haltproc
+  .set SysTick_interrupt, Haltproc
+  .set PM_interrupt, Haltproc
+  .set SYSCTRL_interrupt, Haltproc
+  .set WDT_interrupt, Haltproc
+  .set RTC_interrupt, Haltproc
+  .set EIC_interrupt, Haltproc
+  .set NVMCTRL_interrupt, Haltproc
+  .set DMAC_interrupt, Haltproc
+  .set USB_interrupt, Haltproc
+  .set EVSYS_interrupt, Haltproc
+  .set SERCOM0_interrupt, Haltproc
+  .set SERCOM1_interrupt, Haltproc
+  .set SERCOM2_interrupt, Haltproc
+  .set SERCOM3_interrupt, Haltproc
+  .set SERCOM4_interrupt, Haltproc
+  .set SERCOM5_interrupt, Haltproc
+  .set TCC0_interrupt, Haltproc
+  .set TCC1_interrupt, Haltproc
+  .set TCC2_interrupt, Haltproc
+  .set TC3_interrupt, Haltproc
+  .set TC4_interrupt, Haltproc
+  .set TC5_interrupt, Haltproc
+  .set TC6_interrupt, Haltproc
+  .set TC7_interrupt, Haltproc
+  .set ADC_interrupt, Haltproc
+  .set AC_interrupt, Haltproc
+  .set DAC_interrupt, Haltproc
+  .set PTC_interrupt, Haltproc
+  .set I2S_interrupt, Haltproc
+
+  .text
+  end;
+end.
